<!DOCTYPE html><html><head><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta charset="utf-8"><title>操作系统形式化验证实践教程(3) - 自动证明工具 - 哲学系炼金术指南</title><meta name="description" content=""><meta name="author" content=""><meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1,minimum-scale=1"><link rel="stylesheet" href="assets/css/bulma.min.css"><link rel="stylesheet" href="assets/css/app.css"><!--[if lt IE 9]>
<script src="//cdnjs.cloudflare.com/ajax/libs/html5shiv/3.7.2/html5shiv.min.js"></script>
<script src="//cdnjs.cloudflare.com/ajax/libs/respond.js/1.4.2/respond.min.js"></script>
<![endif]--><link rel="shortcut icon" href=""></head><body dir="ltr"><nav class="columns navbar"><div class="column logo is-3 is-offset-1"><a class="is-brand" href="index.html">哲学系炼金术指南</a></div></nav><div class="columns content"><div class="column is-2-desktop is-3-widescreen is-hidden-touch"></div><div class="column article-container is-11-tablet is-8-desktop is-6-widescreen"><div class="breadcrumb-area"><a href="index.html" class="breadcrumb-item">Home</a><span class="breadcrumb-delimiter"> &gt; </span><a href="fv3.html" class="breadcrumb-item">操作系统形式化验证实践教程(3) - 自动证明工具</a></div><h1 class="article-title">操作系统形式化验证实践教程(3) - 自动证明工具</h1><div class="article"><h2 id="归纳推理的推广">归纳推理的推广 <a class="markdownIt-Anchor" href="#归纳推理的推广">#</a></h2><p>在第一节，我们学习了自然性的归纳法推理。大家都学过数学归纳法，对此应该或清晰或模糊有个概念。</p><p>其实，大家打破思维限制，归纳推理其实可以应用在更广阔的领域。</p><p>比如，我们想一想，基于第二节所讲的列表，有哪些定理可以通过归纳法证明？<br>我们举个例子，大家有没有想到，如何证明：将一个列表反转两次，所得的列表与原列表是相等的？</p><p>我们来试着用之前的apply(induction)和apply(auto)的方法证明一下：</p><pre class="hljs"><code>lemma &quot;rev (rev xs) = xs&quot;
  apply(induction xs)
   apply(auto)
  done
</code></pre><p>输出如下，首先是针对空列表[]的证明，然后是个递推证明a # xs：</p><pre class="hljs"><code>proof (prove)
goal (2 subgoals):
 1. rev (rev []) = []
 2. ⋀a xs.
       rev (rev xs) = xs ⟹ rev (rev (a # xs)) = a # xs
</code></pre><p>这还不过瘾，咱们再折腾下，将列表反转4次试试：</p><pre class="hljs"><code>lemma &quot;rev(rev(rev(rev xs))) = xs&quot;
  apply(induction xs)
   apply(auto)
  done
</code></pre><p>一样可以自动证明出来哈：</p><pre class="hljs"><code>proof (prove)
goal (2 subgoals):
 1. rev (rev (rev (rev []))) = []
 2. ⋀a xs.
       rev (rev (rev (rev xs))) = xs ⟹
       rev (rev (rev (rev (a # xs)))) = a # xs
</code></pre><p>我膨胀了，咱们来个直觉上不太好想的，假设有两个列表，它们正向连接和反向连接相等，它们的长度也相等，求证：这两个列表相等：</p><pre class="hljs"><code>lemma &quot;⟦ xs @ ys = ys @ xs; length xs = length ys ⟧ ⟹ xs = ys&quot;
  apply(induction xs)
  apply(auto)
  done
</code></pre><p>上一条里面生词比较多哈，左右括号分别是lbrakk和rbrakk，推出是Longrightarrow。我们看一下其源代码：</p><pre class="hljs"><code>lemma &quot;\&lt;lbrakk&gt; xs @ ys = ys @ xs; length xs = length ys \&lt;rbrakk&gt; \&lt;Longrightarrow&gt; xs = ys&quot;
  apply(induction xs)
  apply(auto)
  done
</code></pre><p>这下确实auto推不出来了：<br><img src="https://upload-images.jianshu.io/upload_images/1638145-dc9a88edf60d8ff5.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="conj"></p><p>自动推理不出来，我们可以通过增加辅助证明的方式来帮助它。这个有点小复杂，我们后面再讲。<br>这里，我们先推介出大杀器，可以用于自动定理证明的大杀器 - sledgehammer。</p><h2 id="sledgehammer">sledgehammer <a class="markdownIt-Anchor" href="#sledgehammer">#</a></h2><p>sledgehammer是一个帮助我们搜索证明方法的利器。我们要证明的问题，很多可能是前人早已经证明过的。<br>我们可以有三种方式：</p><ol><li>重造轮子，自己再证明一遍</li><li>去库里里面找一个</li><li>工具帮我们找一个<br>实现第三种操作的工具就是sledgehammer。</li></ol><p>我们从output区域切换到sledgehammer, Prover证明器先选cvc4，点击Apply，看到的结果如下：<br><img src="https://upload-images.jianshu.io/upload_images/1638145-07bc1d699c390c37.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="sledgehammer"></p><p>输出为：</p><pre class="hljs"><code>Proof found... 
&quot;cvc4&quot;: Try this: using append_eq_append_conv by blast (35 ms)
</code></pre><p>我们就用cvc4让我们try的这条，来替代apply那几句：</p><pre class="hljs"><code>lemma &quot;⟦ xs @ ys = ys @ xs; length xs = length ys ⟧ ⟹ xs = ys&quot;
using append_eq_append_conv by blast
</code></pre><p>恭喜你，证明这就算做完了。<br><img src="https://upload-images.jianshu.io/upload_images/1638145-c32be7f23a02ed3f.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="append_eq_append_conv"></p><h2 id="更多证明器">更多证明器 <a class="markdownIt-Anchor" href="#更多证明器">#</a></h2><p>cvc4只是众多证明器中的一个，我们还有很多种选择，比如系统默认给我们提供了一个更多选择：<br><img src="https://upload-images.jianshu.io/upload_images/1638145-55c7af23b9eda4ac.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="more prover"></p><p>找到之后，我们把鼠标移到相应的建议上点击，就可以直接输入到源代中：</p><pre class="hljs"><code>lemma &quot;⟦ xs @ ys = ys @ xs; length xs = length ys ⟧ ⟹ xs = ys&quot;
  by (metis append_eq_conv_conj)
</code></pre><figure><img src="https://upload-images.jianshu.io/upload_images/1638145-f887e2c22fcd9fef.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""><figcaption>metis</figcaption></figure><p>sledgehammer的背后，是一系列的自动定理证明器和SMT solvers。关于它们的原理，后面有机会详细介绍下，这是我喜欢的话题。</p><h2 id="定理搜索器">定理搜索器 <a class="markdownIt-Anchor" href="#定理搜索器">#</a></h2><p>Isabelle IDE中也有针对定理的搜索功能，如果各种证明器都找不到的话，可以人肉去研究下：</p><figure><img src="https://upload-images.jianshu.io/upload_images/1638145-da43e2b0adf1faea.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""><figcaption>find theorems</figcaption></figure><p>有了上面的自动定理证明工具和定理搜索工具，在后面我们学习原理的同时，特别鼓励大家能自动的就自动，能借用的就借用。原理可以在使用中慢慢加深，用高深理论把大家吓跑不是本系列的目的，能够帮助大家在工作中把方法和工具用起来才是。</p></div><div dir="ltr" class="level article-bar is-mobile"><div class="level-item has-text-centered"><a title="previous page" class="previouse-article-link" href="fv2.html"><span class="icon icon-previous" data-icon="previous"></span><span class="link-content">&laquo; Previous</span></a></div><div class="level-item has-text-centered"><a title="font size" class="link-item link-item-size"><span class="icon icon-size" data-icon="size"></span></a></div><div class="level-item has-text-centered"><a title="table of content" class="link-item link-item-toc"><span class="icon icon-toc" data-icon="toc"></span></a></div><div class="level-item has-text-centered"><a title="top" href="#"><span class="icon icon-up" data-icon="up"></span> <span class="link-content">⤊ Top</span></a></div><div class="level-item has-text-centered"><a title="next page" class="next-article-link" href="fv4.html"><span class="icon icon-next" data-icon="next"></span><span class="link-content">Next &raquo;</span></a></div></div></div><div class="column is-2-widescreen is-hidden"></div></div><div class="columns foot"><div class="column is-3 is-offset-9 build-by">Build by <a href="https://github.com/ruanyf/loppo" target="_blank">Loppo</a> 0.6.20</div></div><div class="book-toc notification is-warning is-hidden"><h3>Table of chapters &nbsp;<span class="title-close"><a class="button is-danger"> Close</a></span></h3><ul class="chapter-area"><li class="chapter-item"><a href="fv1.html">操作系统形式化验证实践教程(1) - 证明第一个定理</a></li><li class="chapter-item"><a href="fv10.html">操作系统形式化验证实践教程(10) - 一阶直觉逻辑</a></li><li class="chapter-item"><a href="fv11.html">操作系统形式化验证实践教程(11) - 结构化证明语言Isar</a></li><li class="chapter-item"><a href="fv12.html">操作系统形式化验证实践教程(12) - 经典命题逻辑与公式查错方法</a></li><li class="chapter-item"><a href="fv13.html">操作系统形式化验证实践教程(13) - 符号的输入方法</a></li><li class="chapter-item"><a href="fv2.html">操作系统形式化验证实践教程(2) - HOL列表与集合</a></li><li class="chapter-item chapter-item-current"><a href="fv3.html">操作系统形式化验证实践教程(3) - 自动证明工具</a></li><li class="chapter-item"><a href="fv4.html">操作系统形式化验证实践教程(4) - 工具环境</a></li><li class="chapter-item"><a href="fv5.html">操作系统形式化验证实践教程(5) - 搭建seL4环境</a></li><li class="chapter-item"><a href="fv6.html">操作系统形式化验证实践教程(6) - 解析C源代码</a></li><li class="chapter-item"><a href="fv7.html">操作系统形式化验证实践教程(7) - C代码的自动验证</a></li><li class="chapter-item"><a href="fv8.html">操作系统形式化验证实践教程(8) - 用Haskell做系统建模</a></li><li class="chapter-item"><a href="fv9.html">操作系统形式化验证实践教程(9) - 规范与证明概述</a></li></ul></div><div class="progress-indicator"></div><!-- SCRIPTS --><script>var LOPPO={current_path:"fv3.md",relative_root_path:"",article_toc:'<ul class="markdownIt-TOC">\n<li><a href="#%E5%BD%92%E7%BA%B3%E6%8E%A8%E7%90%86%E7%9A%84%E6%8E%A8%E5%B9%BF">归纳推理的推广</a></li>\n<li><a href="#sledgehammer">sledgehammer</a></li>\n<li><a href="#%E6%9B%B4%E5%A4%9A%E8%AF%81%E6%98%8E%E5%99%A8">更多证明器</a></li>\n<li><a href="#%E5%AE%9A%E7%90%86%E6%90%9C%E7%B4%A2%E5%99%A8">定理搜索器</a></li>\n</ul>\n'}</script><script src="assets/js/app.js"></script></body></html>