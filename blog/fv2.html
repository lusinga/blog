<!DOCTYPE html><html><head><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta charset="utf-8"><title>操作系统形式化验证实践教程(2) - HOL列表与集合 - 哲学系炼金术指南</title><meta name="description" content=""><meta name="author" content=""><meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1,minimum-scale=1"><link rel="stylesheet" href="assets/css/bulma.min.css"><link rel="stylesheet" href="assets/css/app.css"><!--[if lt IE 9]>
<script src="//cdnjs.cloudflare.com/ajax/libs/html5shiv/3.7.2/html5shiv.min.js"></script>
<script src="//cdnjs.cloudflare.com/ajax/libs/respond.js/1.4.2/respond.min.js"></script>
<![endif]--><link rel="shortcut icon" href=""></head><body dir="ltr"><nav class="columns navbar"><div class="column logo is-3 is-offset-1"><a class="is-brand" href="index.html">哲学系炼金术指南</a></div></nav><div class="columns content"><div class="column is-2-desktop is-3-widescreen is-hidden-touch"></div><div class="column article-container is-11-tablet is-8-desktop is-6-widescreen"><div class="breadcrumb-area"><a href="index.html" class="breadcrumb-item">Home</a><span class="breadcrumb-delimiter"> &gt; </span><a href="fv2.html" class="breadcrumb-item">操作系统形式化验证实践教程(2) - HOL列表与集合</a></div><h1 class="article-title">操作系统形式化验证实践教程(2) - HOL列表与集合</h1><div class="article"><h1 id="操作系统形式化验证实践教程2---hol列表与集合">操作系统形式化验证实践教程(2) - HOL列表与集合 <a class="markdownIt-Anchor" href="#操作系统形式化验证实践教程2---hol列表与集合">#</a></h1><p>在进入相对比较烧脑的证明过程之前，我们先熟悉下HOL语言中处理列表和集合数据结构的部分。<br>这部分各种函数式语言其实是大同小异的，学习成本比较低。</p><h2 id="列表类型">列表类型 <a class="markdownIt-Anchor" href="#列表类型">#</a></h2><p>HOL的列表类型与别的语言比较像，也是使用[]来表示。类型只要相同就可以，比如我们以整数类型列表为例：</p><pre class="hljs"><code>value &quot;[uminus int(1),int(0),int(1)]&quot;
</code></pre><p>值和类型如下：</p><pre class="hljs"><code>&quot;[- 1, 0, 1]&quot;
  :: &quot;int list&quot;
</code></pre><p>[]是Nil，是空列表。<br>除了用[int1,int2]这样表示外，也可以用int1 # int2 # []的方式来描述。#是Cons操作，为将两个列表连接在一起的操作。</p><p>来看个例子：</p><pre class="hljs"><code>value &quot;nat(2) # nat(10)# []&quot;
</code></pre><p>值为：</p><pre class="hljs"><code>&quot;[2, 10]&quot;
  :: &quot;nat list&quot;
</code></pre><p>可以用&quot;..&quot;来生成序列，例：</p><pre class="hljs"><code>value &quot;[int(1)..int(10)]&quot;
</code></pre><p>值为：</p><pre class="hljs"><code>&quot;[1, 2, 3, 4, 5, 6, 7, 8, 9, 10]&quot;
  :: &quot;int list&quot;
</code></pre><h3 id="求表头">求表头 <a class="markdownIt-Anchor" href="#求表头">#</a></h3><p>hd函数用于求列表表头。<br>例：</p><pre class="hljs"><code>value &quot;hd [int(1),int(3),int(5)]&quot;
</code></pre><p>结果为：</p><pre class="hljs"><code>&quot;1&quot;
  :: &quot;int&quot;
</code></pre><h3 id="除表头外剩余部分">除表头外剩余部分 <a class="markdownIt-Anchor" href="#除表头外剩余部分">#</a></h3><p>用tl函数来求除表头外剩余部分，比如下表，就是除掉表头1之后，2到10的列表：</p><pre class="hljs"><code>value &quot;tl [int(1)..int(10)]&quot;
</code></pre><p>结果为：</p><pre class="hljs"><code>&quot;[2, 3, 4, 5, 6, 7, 8, 9, 10]&quot;
  :: &quot;int list&quot;
</code></pre><h3 id="求表尾元素">求表尾元素 <a class="markdownIt-Anchor" href="#求表尾元素">#</a></h3><p>与tl不同，last用来求最后一个元素，例：</p><pre class="hljs"><code>value &quot;last [int(1)..int(20)]&quot;
</code></pre><p>结果为20：</p><pre class="hljs"><code>&quot;20&quot;
  :: &quot;int&quot;
</code></pre><h3 id="求列表长度">求列表长度 <a class="markdownIt-Anchor" href="#求列表长度">#</a></h3><p>length函数可以计算列表的长度，例：</p><pre class="hljs"><code>value &quot;length [int(1)..int(102)]&quot;
</code></pre><p>结果为：</p><pre class="hljs"><code>&quot;102&quot;
  :: &quot;nat&quot;
</code></pre><p>请注意长度结果是nat自然数，而不是int整数。因为长度不可能为负的。</p><h3 id="截掉列表的内容">截掉列表的内容 <a class="markdownIt-Anchor" href="#截掉列表的内容">#</a></h3><p>比如截掉头部的两个元素，可以通过drop 2 [列表] 来实现：</p><pre class="hljs"><code>value &quot;drop 2 [int(1)..int(5)]&quot;
</code></pre><p>输出结果为：</p><pre class="hljs"><code>&quot;[3, 4, 5]&quot;
  :: &quot;int list&quot;
</code></pre><h3 id="列表反序">列表反序 <a class="markdownIt-Anchor" href="#列表反序">#</a></h3><p>reverse将现有列表顺序反过来：</p><pre class="hljs"><code>value &quot;rev [int(1)..int(5)]&quot;
</code></pre><p>结果为：</p><pre class="hljs"><code>&quot;[5, 4, 3, 2, 1]&quot;
  :: &quot;int list&quot;
</code></pre><h3 id="列表值求和">列表值求和 <a class="markdownIt-Anchor" href="#列表值求和">#</a></h3><p>HOL中的sum_list函数可以求数值列表的元素的值的和：</p><pre class="hljs"><code>value &quot;sum_list [int(1)..int(100)]&quot;
</code></pre><p>结果为：</p><pre class="hljs"><code>&quot;5050&quot;
  :: &quot;int&quot;
</code></pre><h3 id="排序">排序 <a class="markdownIt-Anchor" href="#排序">#</a></h3><p>列表支持sort函数用来排序：</p><pre class="hljs"><code>value &quot;sort (rev[int(5)..int(10)])&quot;
</code></pre><p>结果为：</p><pre class="hljs"><code>&quot;[5, 6, 7, 8, 9, 10]&quot;
  :: &quot;int list&quot;
</code></pre><h3 id="将列表转换成集合">将列表转换成集合 <a class="markdownIt-Anchor" href="#将列表转换成集合">#</a></h3><p>通过set函数可以将列表转换成集合：</p><pre class="hljs"><code>value &quot;set [int(1)..int(5)]&quot;
</code></pre><p>结果如下：</p><pre class="hljs"><code>&quot;{1, 2, 3, 4, 5}&quot;
  :: &quot;int set&quot;
</code></pre><p>上面的内容写得相对比较多，不是想写成手册，而是希望借着操练比较熟悉的内容的机会，让大家尽可能地熟悉Isabelle/HOL的环境，消除恐惧感。</p><h2 id="集合">集合 <a class="markdownIt-Anchor" href="#集合">#</a></h2><p>与列表类似，HOL支持以{}表示的集合类型。</p><p>与列表一样，集合也支持通过序列生成：</p><pre class="hljs"><code>value &quot;{int(1)..int(10)}&quot;
</code></pre><p>结果为：</p><pre class="hljs"><code>&quot;{1, 2, 3, 4, 5, 6, 7, 8, 9, 10}&quot;
  :: &quot;int set&quot;
</code></pre><h3 id="插入元素">插入元素 <a class="markdownIt-Anchor" href="#插入元素">#</a></h3><p>通过insert函数将元素插入到集合中：</p><pre class="hljs"><code>value &quot;insert (int(100)) {int(1)..int(10)}&quot;
</code></pre><p>结果为：</p><pre class="hljs"><code>&quot;{100, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10}&quot;
  :: &quot;int set&quot;
</code></pre><h3 id="判断元素是否属于集合">判断元素是否属于集合 <a class="markdownIt-Anchor" href="#判断元素是否属于集合">#</a></h3><p>比起其它语言用的in操作，HOL直接使用∈符号，输入时写作'\<in>'</in></p><pre class="hljs"><code>value &quot;(int(10)) ∈ {int(1)..int(100)}&quot;
</code></pre><p>源代码实际上为：</p><pre class="hljs"><code>value &quot;(int(10)) \&lt;in&gt; {int(1)..int(100)}&quot;
</code></pre><h3 id="交集与并集">交集与并集 <a class="markdownIt-Anchor" href="#交集与并集">#</a></h3><p>交集和并集直接使用∩和∪。输入时用\<inter>和\<union>表示。</union></inter></p><p>我们看下并集的例子：</p><pre class="hljs"><code>value &quot;{int(1)..int(5)} ∪ {int(100)..int(120)}&quot;
</code></pre><p>输出为：</p><pre class="hljs"><code>&quot;{5, 4, 3, 2, 1, 100, 101, 102, 103, 104, 105, 106, 107,
  108, 109, 110, 111, 112, 113, 114, 115, 116, 117, 118,
  119, 120}&quot;
  :: &quot;int set&quot;
</code></pre><figure><img src="https://upload-images.jianshu.io/upload_images/1638145-6ccc6137cd8e1c8f.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""><figcaption>并集</figcaption></figure><p>再来看一个交集的例子：</p><pre class="hljs"><code>value &quot;{int(1)..int(105)} ∩ {int(100)..int(120)}&quot;
</code></pre><p>结果如下：</p><pre class="hljs"><code>&quot;{100, 101, 102, 103, 104, 105}&quot;
  :: &quot;int set&quot;
</code></pre><h3 id="幂集">幂集 <a class="markdownIt-Anchor" href="#幂集">#</a></h3><p>幂集是由集合的所有子集所组合的集合。<br>我们看个最简单的例子，大家就能理解了：</p><pre class="hljs"><code>value &quot;Pow {int(1)..int(2)}&quot;
</code></pre><p>组合的结果应该为空集，1的集合，2的集合和这个集合本身。</p><pre class="hljs"><code>&quot;{{2}, {}, {1}, {1, 2}}&quot;
  :: &quot;int set set&quot;
</code></pre><p>巩固一下，如果扩展到5个元素，你还能写全吗？</p><pre class="hljs"><code>value &quot;Pow {int(1)..int(5)}&quot;
</code></pre><p>结果为：</p><pre class="hljs"><code>&quot;{{2, 3, 4, 5}, {2, 3, 4}, {2, 3}, {2, 3, 5}, {2, 5}, {2},
  {2, 4}, {2, 4, 5}, {4, 5}, {4}, {}, {5}, {3, 5}, {3},
  {3, 4}, {3, 4, 5}, {1, 3, 4, 5}, {1, 3, 4}, {1, 3},
  {1, 3, 5}, {1, 5}, {1}, {1, 4}, {1, 4, 5}, {1, 2, 4, 5},
  {1, 2, 4}, {1, 2}, {1, 2, 5}, {1, 2, 3, 5}, {1, 2, 3},
  {1, 2, 3, 4}, {1, 2, 3, 4, 5}}&quot;
  :: &quot;int set set&quot;
</code></pre><h3 id="量词">量词 <a class="markdownIt-Anchor" href="#量词">#</a></h3><p>HOL终于要开始展示真实本领了，作为一种逻辑语言，它是支持量词的，也就是<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi mathvariant="normal">∀</mi></mrow><annotation encoding="application/x-tex">\forall</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.69444em;"></span><span class="strut bottom" style="height:0.69444em;vertical-align:0em;"></span><span class="base textstyle uncramped"><span class="mord mathrm">∀</span></span></span></span>和<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi mathvariant="normal">∃</mi></mrow><annotation encoding="application/x-tex">\exists</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.69444em;"></span><span class="strut bottom" style="height:0.69444em;vertical-align:0em;"></span><span class="base textstyle uncramped"><span class="mord mathrm">∃</span></span></span></span>.</p><p>我们还是直接上个例子，对于某个整数集合，所有元素都大于0：</p><pre class="hljs"><code>value &quot;∀x∈{int(1)..int(10000)}. x&gt;0&quot;
</code></pre><p>这自然是真的：</p><pre class="hljs"><code>&quot;True&quot;
  :: &quot;bool&quot;
</code></pre><figure><img src="https://upload-images.jianshu.io/upload_images/1638145-44d911de4e1f1c20.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""><figcaption>量词</figcaption></figure><p>这一期我们从比较熟悉的列表和集合操作，引入一点点逻辑相关的操作。其实就是想让大家看到，让这些LaTex符号运行起来，其实也没有什么神秘的。</p><p>最后，我们发一下这一节完整的源代码：</p><pre class="hljs"><code>theory Test2
  imports Main
begin
value &quot;hd [int(1),int(3),int(5)]&quot;
value &quot;nat(2) # nat(10)# []&quot;
value &quot;int(2) # int(3) # []&quot;
value &quot;tl [nat(2),nat(3)]&quot;
value &quot;[uminus int(1),int(0),int(1)]&quot;
value &quot;[int(1)..int(10)]&quot;
value &quot;tl [int(1)..int(10)]&quot;
value &quot;last [int(1)..int(20)]&quot;
value &quot;length [int(1)..int(102)]&quot;
value &quot;sum_list [int(1)..int(100)]&quot;
value &quot;drop 2 [int(1)..int(5)]&quot;
value &quot;rev [int(1)..int(5)]&quot;
value &quot;set [int(1)..int(5)]&quot;
value &quot;sort (rev[int(5)..int(10)])&quot;
value &quot;{int(1)..int(10)}&quot;
value &quot;insert (int(100)) {int(1)..int(10)}&quot;
value &quot;(int(10)) \&lt;in&gt; {int(1)..int(100)}&quot;
value &quot;{int(1)..int(5)} \&lt;union&gt; {int(100)..int(120)}&quot;
value &quot;{int(1)..int(105)} \&lt;inter&gt; {int(100)..int(120)}&quot;
value &quot;\&lt;forall&gt;x\&lt;in&gt;{int(1)..int(10000)}. x&gt;0&quot;
value &quot;Pow {int(1)..int(2)}&quot;
value &quot;Pow {int(1)..int(5)}&quot;
value &quot;-{int(0)..int(10)}&quot;
(* Tests on values *)
end
</code></pre></div><div dir="ltr" class="level article-bar is-mobile"><div class="level-item has-text-centered"><a title="previous page" class="previouse-article-link" href="fv1.html"><span class="icon icon-previous" data-icon="previous"></span><span class="link-content">&laquo; Previous</span></a></div><div class="level-item has-text-centered"><a title="font size" class="link-item link-item-size"><span class="icon icon-size" data-icon="size"></span></a></div><div class="level-item has-text-centered"><a title="table of content" class="link-item link-item-toc"><span class="icon icon-toc" data-icon="toc"></span></a></div><div class="level-item has-text-centered"><a title="top" href="#"><span class="icon icon-up" data-icon="up"></span> <span class="link-content">⤊ Top</span></a></div><div class="level-item has-text-centered"><a title="next page" class="next-article-link" href="fv3.html"><span class="icon icon-next" data-icon="next"></span><span class="link-content">Next &raquo;</span></a></div></div></div><div class="column is-2-widescreen is-hidden"></div></div><div class="columns foot"><div class="column is-3 is-offset-9 build-by">Build by <a href="https://github.com/ruanyf/loppo" target="_blank">Loppo</a> 0.6.20</div></div><div class="book-toc notification is-warning is-hidden"><h3>Table of chapters &nbsp;<span class="title-close"><a class="button is-danger"> Close</a></span></h3><ul class="chapter-area"><li class="chapter-item"><a href="fv1.html">操作系统形式化验证实践教程(1) - 证明第一个定理</a></li><li class="chapter-item chapter-item-current"><a href="fv2.html">操作系统形式化验证实践教程(2) - HOL列表与集合</a></li><li class="chapter-item"><a href="fv3.html">操作系统形式化验证实践教程(3) - 自动证明工具</a></li><li class="chapter-item"><a href="fv4.html">操作系统形式化验证实践教程(4) - 工具环境</a></li><li class="chapter-item"><a href="fv5.html">操作系统形式化验证实践教程(5) - 搭建seL4环境</a></li></ul></div><div class="progress-indicator"></div><!-- SCRIPTS --><script>var LOPPO={current_path:"fv2.md",relative_root_path:"",article_toc:'<ul class="markdownIt-TOC">\n<li><a href="#%E5%88%97%E8%A1%A8%E7%B1%BB%E5%9E%8B">列表类型</a>\n<ul>\n<li><a href="#%E6%B1%82%E8%A1%A8%E5%A4%B4">求表头</a></li>\n<li><a href="#%E9%99%A4%E8%A1%A8%E5%A4%B4%E5%A4%96%E5%89%A9%E4%BD%99%E9%83%A8%E5%88%86">除表头外剩余部分</a></li>\n<li><a href="#%E6%B1%82%E8%A1%A8%E5%B0%BE%E5%85%83%E7%B4%A0">求表尾元素</a></li>\n<li><a href="#%E6%B1%82%E5%88%97%E8%A1%A8%E9%95%BF%E5%BA%A6">求列表长度</a></li>\n<li><a href="#%E6%88%AA%E6%8E%89%E5%88%97%E8%A1%A8%E7%9A%84%E5%86%85%E5%AE%B9">截掉列表的内容</a></li>\n<li><a href="#%E5%88%97%E8%A1%A8%E5%8F%8D%E5%BA%8F">列表反序</a></li>\n<li><a href="#%E5%88%97%E8%A1%A8%E5%80%BC%E6%B1%82%E5%92%8C">列表值求和</a></li>\n<li><a href="#%E6%8E%92%E5%BA%8F">排序</a></li>\n<li><a href="#%E5%B0%86%E5%88%97%E8%A1%A8%E8%BD%AC%E6%8D%A2%E6%88%90%E9%9B%86%E5%90%88">将列表转换成集合</a></li>\n</ul>\n</li>\n<li><a href="#%E9%9B%86%E5%90%88">集合</a>\n<ul>\n<li><a href="#%E6%8F%92%E5%85%A5%E5%85%83%E7%B4%A0">插入元素</a></li>\n<li><a href="#%E5%88%A4%E6%96%AD%E5%85%83%E7%B4%A0%E6%98%AF%E5%90%A6%E5%B1%9E%E4%BA%8E%E9%9B%86%E5%90%88">判断元素是否属于集合</a></li>\n<li><a href="#%E4%BA%A4%E9%9B%86%E4%B8%8E%E5%B9%B6%E9%9B%86">交集与并集</a></li>\n<li><a href="#%E5%B9%82%E9%9B%86">幂集</a></li>\n<li><a href="#%E9%87%8F%E8%AF%8D">量词</a></li>\n</ul>\n</li>\n</ul>\n'}</script><script src="assets/js/app.js"></script></body></html>