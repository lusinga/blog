<!DOCTYPE html><html><head><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta charset="utf-8"><title>操作系统形式化验证实践教程(1) - 证明第一个定理 - 哲学系炼金术指南</title><meta name="description" content=""><meta name="author" content=""><meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1,minimum-scale=1"><link rel="stylesheet" href="assets/css/bulma.min.css"><link rel="stylesheet" href="assets/css/app.css"><!--[if lt IE 9]>
<script src="//cdnjs.cloudflare.com/ajax/libs/html5shiv/3.7.2/html5shiv.min.js"></script>
<script src="//cdnjs.cloudflare.com/ajax/libs/respond.js/1.4.2/respond.min.js"></script>
<![endif]--><link rel="shortcut icon" href=""></head><body dir="ltr"><nav class="columns navbar"><div class="column logo is-3 is-offset-1"><a class="is-brand" href="index.html">哲学系炼金术指南</a></div></nav><div class="columns content"><div class="column is-2-desktop is-3-widescreen is-hidden-touch"></div><div class="column article-container is-11-tablet is-8-desktop is-6-widescreen"><div class="breadcrumb-area"><a href="index.html" class="breadcrumb-item">Home</a><span class="breadcrumb-delimiter"> &gt; </span><a href="fv1.html" class="breadcrumb-item">操作系统形式化验证实践教程(1) - 证明第一个定理</a></div><h1 class="article-title">操作系统形式化验证实践教程(1) - 证明第一个定理</h1><div class="article"><p>形式化方法分为三个主要部分：系统建模(System Modeling)、形式规约(Formal Specification)和形式化验证(Formal Verification)。<br>其中系统建模用形式化的模型来描述系统及其行为模式。建模完成后，需要用形式规约来精确描述建模出来的需求。有了规约，如何检验是否符合规约呢?这就需要形式化验证方法。</p><p>形式化验证方法主要分为两类：一类是以穷尽搜索为基础的模型检测，另一类是以逻辑推理为基础的演绎逻辑。相对于前者，后者既可以验证有穷的状态系统，也可以使用归纳法来处理无限状态的问题。</p><p>演绎逻辑在早期发展很快，但是后来在大规模软件验证上成本较高，所以发展一直不快。但是，最近十几年，以seL4为代表的操作系统和CompCert为代表的编译器的正确性证明的完成，给形式化验证带来了重要的突破性进展。<br>这也带来了两大流派：seL4所使用的Isabelle/HOL工具和CompCert所使用的Coq工具。<br>Isabelle是基于Standard ML语言开发的，支持生成Standard ML, ocaml, Haskell和Scala语言的代码。而Coq是基于ocaml语言的。</p><p>波澜壮阔的操作系统级的验证全景，我们后面会徐徐展开。做为一个落地的教程，我们千里之行始于足下，先从Isabelle/HOL工具的使用开始说起。</p><h2 id="isabellehol简介">Isabelle/HOL简介 <a class="markdownIt-Anchor" href="#isabellehol简介">#</a></h2><p>Isabelle/HOL可以通过下面的网址下载和安装：<a href="https://www.cl.cam.ac.uk/research/hvg/Isabelle/installation.html" target="_blank" rel="noopener">https://www.cl.cam.ac.uk/research/hvg/Isabelle/installation.html</a>。支持Linux/mac/Windows平台。</p><p>以Linux为例，我们可以先通过wget工具下载tar.gz包：</p><pre class="hljs"><code>wget -c https://www.cl.cam.ac.uk/research/hvg/Isabelle/dist/Isabelle2020_linux.tar.gz
</code></pre><p>HOL是High Order Logic，即高阶逻辑的缩写。</p><p>废话不多说，Isabelle封装在jEdit中，有完整的集成开发环境。我们安装好了之后直接打开看一眼：</p><figure><img src="https://upload-images.jianshu.io/upload_images/1638145-8e4275af60afb16e.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""><figcaption>Isabelle/HOL</figcaption></figure><p>有几点不跟普通编程语言的不同之处：</p><ul><li>HOL的代码以theory组织在一起</li><li>theory之下有函数fun,值value, 有公式lemma, theorem等</li><li>当我们把光标放到lemma或theorem中时，发现系统可以自动帮我们做一些推理的验证</li><li>HOL代码中大量使用非ASCII符号，可能给用惯了ASCII字符的程序员们带来一定的不适应，但是可读性绝对比用ASCII表示要上一个层次</li></ul><h2 id="自动证明第一个定理">自动证明第一个定理 <a class="markdownIt-Anchor" href="#自动证明第一个定理">#</a></h2><p>同其它编程语言类似，HOL也有自己的数据类型系统。我们先从最简单的布尔类型开始。</p><p>HOL支持bool来表示布尔类型。用True表示真值，False表示假值。<br>取反为<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi mathvariant="normal">¬</mi></mrow><annotation encoding="application/x-tex">\lnot</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.43056em;"></span><span class="strut bottom" style="height:0.43056em;vertical-align:0em;"></span><span class="base textstyle uncramped"><span class="mord mathrm">¬</span></span></span></span>, 取交为<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo>∧</mo></mrow><annotation encoding="application/x-tex">\land</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.55556em;"></span><span class="strut bottom" style="height:0.55556em;vertical-align:0em;"></span><span class="base textstyle uncramped"><span class="mord">∧</span></span></span></span>，取并为<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo>∨</mo></mrow><annotation encoding="application/x-tex">\lor</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.55556em;"></span><span class="strut bottom" style="height:0.55556em;vertical-align:0em;"></span><span class="base textstyle uncramped"><span class="mord">∨</span></span></span></span>。</p><p>下面我们写一个求布尔交的函数。<br>交函数的输入为两个bool，输出也是一个bool.<br>我们用&quot;bool ⇒ bool ⇒ bool&quot;来描述这个函数的类型。<br>“⇒”的输入方法是用TeX值：&lt;\Rightarrow&gt;.<br>HOL语句要用字符串符号&quot;&quot;来括起来，原理我们后面再讲。<br>代码逻辑上，除了输入为True和True返回True之外，其它都返回False:</p><pre class="hljs"><code>fun conj2 :: &quot;bool ⇒ bool ⇒ bool&quot; where
&quot;conj2 True True = True&quot;|
&quot;conj2 _ _ = False&quot;
</code></pre><p>下面高光时刻来了，我们来用Isabelle/HOL证明我们学习之旅中的第一个定理False与另一个布尔值取conj2操作，结果一定为False。</p><pre class="hljs"><code>lemma conj_02: &quot;conj2 False m = False&quot;
  apply(induction m)
   apply(auto)
  done
</code></pre><p>apply(induction m)和apply(auto)的作用是让HOL自动帮我们推断证明。<br>把光标放到apply(auto)语句，我们从output窗口看到：</p><pre class="hljs"><code>proof (prove)
goal (2 subgoals):
 1. conj2 False True = False
 2. conj2 False False = False
</code></pre><p>如图所示：<br><img src="https://upload-images.jianshu.io/upload_images/1638145-5d5d1df63ba78554.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="conj02"></p><p>趁热打铁，我们再写一个练习下：</p><pre class="hljs"><code>fun not2 :: &quot;bool ⇒ bool&quot; where
&quot;not2 True = False&quot; |
&quot;not2 False = True&quot;
lemma not02 : &quot;not2 x = (¬ x)&quot;
  apply(induction x)
  apply(auto)
  done
</code></pre><figure><img src="https://upload-images.jianshu.io/upload_images/1638145-cbbae96b576c8bac.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""><figcaption>lnot</figcaption></figure><h2 id="从有限到无限">从有限到无限 <a class="markdownIt-Anchor" href="#从有限到无限">#</a></h2><p>恭喜大家，已经学会证明有限情况下的定理证明了。但是这还不够，我们还要能证明无限的情况。<br>下面我们就从有限的布尔类型，前进到自然数类型nat和整数类型int.</p><p>自然数的定义带着浓浓的数学归纳法的味道。这里用到了求后继函数Suc：自然数nat = 0 或 Suc nat。也就是说，自然数定义为0，Suc(0), Suc(Suc(0))...</p><p>有了这个定义，我们可以重新定义一个加法了：</p><pre class="hljs"><code>fun add2 ::&quot;nat ⇒ nat ⇒nat&quot; where 
&quot;add2 0 n = n&quot; | 
&quot;add2 (Suc m) n = Suc(add2 m n)&quot;
</code></pre><p>首先是0和n进行add2等于n，然后是m的后继与n进行add2操作，等于m与n进行add2操作后再求后继。</p><p>这么说有点抽象，我们来看例子。</p><p>第一个例子：add2 0 1，根据定义，这个就等于1。这个容易理解。<br>第二个例子：add2 1 2。1是Suc 0，于是这个式子为Suc(add2 0 2)，add2 0 2根据第一条定义式结果为2。<br>第三个例子：add2 2 3。2是Suc 1，于是式子为Suc(add2 1 3)，再递推为Suc(Suc(add2 0 3)，结果为5.</p><p>这样，通过这样一种递推关系，我们重新定义了加法。</p><p>那么，这个我们新定义的加法，归纳出来的加法，跟真实的加法是不是一致呢？我们写个定理去进行自动证明：</p><pre class="hljs"><code>lemma add_02: &quot;add2 m n = m+n&quot;
  apply(induction m)
  apply(auto)
  done
</code></pre><p>下面是证明的结果：</p><pre class="hljs"><code>proof (prove)
goal (2 subgoals):
 1. add2 0 n = 0 + n
 2. ⋀m. add2 m n = m + n ⟹ add2 (Suc m) n = Suc m + n
</code></pre><p>根据两个初始条件，有两个子目标需要证明：<br>第一个是初始条件，add2 0 n = 0+n。<br>第二个是基于后继的递推条件。</p><h3 id="皮亚诺公理">皮亚诺公理 <a class="markdownIt-Anchor" href="#皮亚诺公理">#</a></h3><p>上面的证明方法叫做归纳原理，也叫做皮亚诺第五公理。<br>我们来从头看下这5条公理：</p><ol><li>0是一个自然数</li><li>任何自然数n都有一个自然数Suc(n)作为它的后继</li><li>0不是任何自然数的后继</li><li>后继函数是单一的，即，如果Suc(m)=Suc(n)，则m=n.</li><li>令Q为关于自然数的一个性质。如果</li></ol><ul><li>0具有性质Q</li><li>并且 如果自然数n具有性质Q，则Suc(n)也具有性质Q</li><li>那么所有自然数n都有性质Q</li></ul><p>在此基础上，我们可以定义加法和乘法。</p><ul><li>加法：对于任何自然数n和m：<ul><li>n + 0 = n</li><li>并且 n + Suc(m) = Suc(n + m)</li></ul></li><li>乘法：对任何自然数n和m:<ul><li>n * 0 = 0</li><li>n <em>Suc(m) = (n </em>m) + n</li></ul></li></ul><p>乘法的定理证明如下：</p><pre class="hljs"><code>fun mul2 ::&quot;nat ⇒ nat ⇒nat&quot; where 
&quot;mul2 0 n = 0&quot; | 
&quot;mul2 (Suc m) n = n * m + n&quot;

lemma add_02: &quot;mul2 m n = m * n&quot;
  apply(induction m)
  apply(auto)
  done
</code></pre><h2 id="求值">求值 <a class="markdownIt-Anchor" href="#求值">#</a></h2><p>在过程中，难免有些值我们希望看到输出结果，这时可以通过value语句来实现。</p><p>例：</p><pre class="hljs"><code>value &quot;Suc(0)&quot;
</code></pre><p>输出结果为：</p><pre class="hljs"><code>&quot;1&quot;
  :: &quot;nat&quot;
</code></pre><p>1为结果的值，nat是类型。</p><p>调用我们自己定义的函数也没有问题：</p><pre class="hljs"><code>value &quot;add2 1 (Suc 4)&quot;
</code></pre><p>输出结果为：</p><pre class="hljs"><code>&quot;6&quot;
  :: &quot;nat&quot;
</code></pre><p>恭喜你，我们已经在定理证明的世界里证明了第一个定理。<br>后面的路很长，坡也有点陡，我们继续前进。</p></div><div dir="ltr" class="level article-bar is-mobile"><div class="level-item has-text-centered"><a title="previous page" class="previouse-article-link" href="index.html"><span class="icon icon-previous" data-icon="previous"></span><span class="link-content">&laquo; Previous</span></a></div><div class="level-item has-text-centered"><a title="font size" class="link-item link-item-size"><span class="icon icon-size" data-icon="size"></span></a></div><div class="level-item has-text-centered"><a title="table of content" class="link-item link-item-toc"><span class="icon icon-toc" data-icon="toc"></span></a></div><div class="level-item has-text-centered"><a title="top" href="#"><span class="icon icon-up" data-icon="up"></span> <span class="link-content">⤊ Top</span></a></div><div class="level-item has-text-centered"><a title="next page" class="next-article-link" href="fv2.html"><span class="icon icon-next" data-icon="next"></span><span class="link-content">Next &raquo;</span></a></div></div></div><div class="column is-2-widescreen is-hidden"></div></div><div class="columns foot"><div class="column is-3 is-offset-9 build-by">Build by <a href="https://github.com/ruanyf/loppo" target="_blank">Loppo</a> 0.6.20</div></div><div class="book-toc notification is-warning is-hidden"><h3>Table of chapters &nbsp;<span class="title-close"><a class="button is-danger"> Close</a></span></h3><ul class="chapter-area"><li class="chapter-item chapter-item-current"><a href="fv1.html">操作系统形式化验证实践教程(1) - 证明第一个定理</a></li><li class="chapter-item"><a href="fv2.html">操作系统形式化验证实践教程(2) - HOL列表与集合</a></li><li class="chapter-item"><a href="fv3.html">操作系统形式化验证实践教程(3) - 自动证明工具</a></li><li class="chapter-item"><a href="fv4.html">操作系统形式化验证实践教程(4) - 工具环境</a></li><li class="chapter-item"><a href="fv5.html">操作系统形式化验证实践教程(5) - 搭建seL4环境</a></li></ul></div><div class="progress-indicator"></div><!-- SCRIPTS --><script>var LOPPO={current_path:"fv1.md",relative_root_path:"",article_toc:'<ul class="markdownIt-TOC">\n<li><a href="#isabellehol%E7%AE%80%E4%BB%8B">Isabelle/HOL简介</a></li>\n<li><a href="#%E8%87%AA%E5%8A%A8%E8%AF%81%E6%98%8E%E7%AC%AC%E4%B8%80%E4%B8%AA%E5%AE%9A%E7%90%86">自动证明第一个定理</a></li>\n<li><a href="#%E4%BB%8E%E6%9C%89%E9%99%90%E5%88%B0%E6%97%A0%E9%99%90">从有限到无限</a>\n<ul>\n<li><a href="#%E7%9A%AE%E4%BA%9A%E8%AF%BA%E5%85%AC%E7%90%86">皮亚诺公理</a></li>\n</ul>\n</li>\n<li><a href="#%E6%B1%82%E5%80%BC">求值</a></li>\n</ul>\n'}</script><script src="assets/js/app.js"></script></body></html>