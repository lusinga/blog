<!DOCTYPE html><html><head><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta charset="utf-8"><title>操作系统形式化验证实践教程(7) - C代码的自动验证 - 哲学系炼金术指南</title><meta name="description" content=""><meta name="author" content=""><meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1,minimum-scale=1"><link rel="stylesheet" href="assets/css/bulma.min.css"><link rel="stylesheet" href="assets/css/app.css"><!--[if lt IE 9]>
<script src="//cdnjs.cloudflare.com/ajax/libs/html5shiv/3.7.2/html5shiv.min.js"></script>
<script src="//cdnjs.cloudflare.com/ajax/libs/respond.js/1.4.2/respond.min.js"></script>
<![endif]--><link rel="shortcut icon" href=""></head><body dir="ltr"><nav class="columns navbar"><div class="column logo is-3 is-offset-1"><a class="is-brand" href="index.html">哲学系炼金术指南</a></div></nav><div class="columns content"><div class="column is-2-desktop is-3-widescreen is-hidden-touch"></div><div class="column article-container is-11-tablet is-8-desktop is-6-widescreen"><div class="breadcrumb-area"><a href="index.html" class="breadcrumb-item">Home</a><span class="breadcrumb-delimiter"> &gt; </span><a href="fv7.html" class="breadcrumb-item">操作系统形式化验证实践教程(7) - C代码的自动验证</a></div><h1 class="article-title">操作系统形式化验证实践教程(7) - C代码的自动验证</h1><div class="article"><p>上一节教程不知道大家看晕了没有，其实虽然细节很多还没有讲清楚，但是从结构上大家可以看到，其实是很模式化的工作。<br>那么能不能让这个模式化的工作自动化起来，也能降低一点入门的学习门槛？这时就该AutoCorres工具出马了。</p><h2 id="autocorres">AutoCorres <a class="markdownIt-Anchor" href="#autocorres">#</a></h2><p>既然回到人间，不用再看着一排的simp, vcg之类的，咱们的难度又回到第一讲加减法的时代。</p><p>先实现一个C语言实现加法的函数：</p><pre class="hljs"><code><span class="hljs-function"><span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">int</span> <span class="hljs-title">plus</span><span class="hljs-params">(<span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">int</span> a, <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">int</span> b)</span>
</span>{
    <span class="hljs-keyword">return</span> a + b;
}
</code></pre><p>下面开始写HOL，先引入AutoCorres：</p><pre class="hljs"><code>imports
  &quot;AutoCorres.AutoCorres&quot;
</code></pre><p>然后还是把C源文件读进来，并且install了：</p><pre class="hljs"><code>external_file &quot;plus.c&quot;
install_C_file &quot;plus.c&quot;
</code></pre><p>然后给c文件autocorres一下：</p><pre class="hljs"><code>autocorres &quot;plus.c&quot;
</code></pre><p>按照惯例locale一下：</p><pre class="hljs"><code>context plus begin
</code></pre><p>实际上执行的是：</p><pre class="hljs"><code>locale Plus.plus
  fixes symbol_table :: &quot;char list ⇒ 32 word&quot;
</code></pre><p>万事俱备，我们现在已经能读懂C代码了。</p><h3 id="通过by-eval验证具体例子">通过by eval验证具体例子 <a class="markdownIt-Anchor" href="#通过by-eval验证具体例子">#</a></h3><p>先写个case验证下：</p><pre class="hljs"><code>lemma &quot;plus' 128 127 = 255&quot;
</code></pre><p>C代码既然懂了，就直接unfold一下：</p><pre class="hljs"><code>  unfolding plus'_def
</code></pre><p>验证对不对，执行一下by eval，完整代码如下：</p><pre class="hljs"><code>lemma &quot;plus' 128 127 = 255&quot;
  unfolding plus'_def
  by eval
</code></pre><h3 id="演绎验证">演绎验证 <a class="markdownIt-Anchor" href="#演绎验证">#</a></h3><p>例子只能证明在这一种情况下是正确的，但无法证明在所有情况下都正确。我们有没有办法证明所有情况下都正确呢？<br>可以的，我们不用by eval了，换个apply的规则就好了：</p><pre class="hljs"><code>lemma plus_correct: &quot;plus' a b = a + b&quot;
  unfolding plus'_def
  apply (rule refl)
  done
</code></pre><p>我们来看下目标：</p><pre class="hljs"><code>proof (prove)
goal (1 subgoal):
 1. a + b = a + b
</code></pre><p>这真的也没啥可以证的了。。。</p><h2 id="自动生成定理和证明">自动生成定理和证明 <a class="markdownIt-Anchor" href="#自动生成定理和证明">#</a></h2><p>我们乘胜追击，再来搞个最大值的：</p><pre class="hljs"><code>unsigned max(unsigned a, unsigned b)
{
    if (a &lt;= b) {
        return b;
    }
    return a;
}
</code></pre><p>后面没啥惊喜的，一条龙：imports AutoCorres, external_file, install_C_file, autocorres, unfolding:</p><pre class="hljs"><code>imports
  &quot;AutoCorres.AutoCorres&quot;
begin

external_file &quot;simple.c&quot;

install_C_file &quot;simple.c&quot;

autocorres &quot;simple.c&quot;

context simple begin

lemma &quot;max' a b = max a b&quot;
  unfolding max'_def max_def
  by (rule refl)
</code></pre><p>下面我们来个更强大的，自动生成定理和证明：</p><pre class="hljs"><code>thm simple.max'_def simple.max'_ac_corres
</code></pre><p>生成的结果如下：</p><pre class="hljs"><code>  simple.max' ?a ?b ≡ if ?a ≤ ?b then ?b else ?a
  ac_corres (simple.lift_global_heap ∘ globals) True
   simple_global_addresses.Γ ret__unsigned_'
   ((λs. a_' s = ?a') and (λs. b_' s = ?b') and
    (λx. abs_var ?a id ?a' ∧ abs_var ?b id ?b') ∘
    simple.lift_global_heap ∘
    globals)
   (L2_gets (λ_. simple.max' ?a ?b) [''ret''])
   (Call max_'proc)
</code></pre><p>虽然autocorres不会知道max跟库中的max有啥关系，但是可以生成<code>if ?a ≤ ?b then ?b else ?a</code>这样的定理。</p><h2 id="验证并非是重复代码逻辑">验证并非是重复代码逻辑 <a class="markdownIt-Anchor" href="#验证并非是重复代码逻辑">#</a></h2><p>刚才我们看到加法还有最大值，已经都被autocorres轻松消解掉了，连定理和证明都可以自动生成了。<br>但是，实际上，形式化验证并没有这么简单。<br>我们看个求最大公约数的例子：</p><pre class="hljs"><code><span class="hljs-function"><span class="hljs-keyword">unsigned</span> <span class="hljs-title">gcd</span><span class="hljs-params">(<span class="hljs-keyword">unsigned</span> a, <span class="hljs-keyword">unsigned</span> b)</span>
</span>{
    <span class="hljs-keyword">unsigned</span> c;
    <span class="hljs-keyword">while</span> (a != <span class="hljs-number">0</span>) {
        c = a;
        a = b % a;
        b = c;
    }
    <span class="hljs-keyword">return</span> b;
}
</code></pre><p>这个如何验证？</p><p>自动生成下：</p><pre class="hljs"><code>thm simple.gcd'_def simple.gcd'_ac_corres
</code></pre><p>结果如下：</p><pre class="hljs"><code>  simple.gcd' ?a ?b ≡
  do (a, b) &lt;- whileLoop (λ(a, b) b. a ≠ 0)
                 (λ(a, b). return (b mod a, a))
                (?a, ?b);
     return b
  od
  ac_corres (simple.lift_global_heap ∘ globals) True
   simple_global_addresses.Γ (unat ∘ ret__unsigned_')
   ((λs. a_' s = ?a') and (λs. b_' s = ?b') and
    (λx. abs_var ?a unat ?a' ∧ abs_var ?b unat ?b') ∘
    simple.lift_global_heap ∘
    globals)
   (liftE (simple.gcd' ?a ?b)) (Call gcd_'proc)
</code></pre><p>这重复了下实现逻辑没错，但是没有体验中最大公约数的本质。</p><p>我们来看下seL4中的实现吧：</p><pre class="hljs"><code>lemma gcd_to_return [simp]:
    &quot;gcd' a b = return (gcd a b)&quot;
  apply (subst monad_to_gets [where v=&quot;λ_. gcd a b&quot;])
    apply (wp gcd_wp)
    apply simp
   apply (clarsimp simp: gcd'_def)
   apply (rule empty_fail_bind)
    apply (rule empty_fail_whileLoop)
    apply (clarsimp simp: split_def)
   apply (clarsimp simp: split_def)
  apply (clarsimp simp: split_def)
  done
</code></pre><p>其中，monad_to_gets是一个辅助定理：</p><pre class="hljs"><code>lemma monad_to_gets:
    &quot;⟦ ⋀P. ⦃ P ⦄ f ⦃ λr s. P s ∧ r = v s ⦄!; empty_fail f ⟧ ⟹ f = gets v&quot;
  apply atomize
  apply (monad_eq simp: validNF_def valid_def no_fail_def empty_fail_def)
  apply (rule conjI)
   apply clarsimp
   apply (drule_tac x=&quot;λs'. s = s'&quot; in spec)
   apply clarsimp
   apply force
  apply clarsimp
  apply (drule_tac x=&quot;λs'. s' = t&quot; in spec)
  apply clarsimp
  apply force
  done
</code></pre><p>求最弱前置条件gcd_wp为：</p><pre class="hljs"><code>lemma gcd_wp [wp]:
    &quot;⦃ P (gcd a b) ⦄ gcd' a b ⦃ P ⦄!&quot;
  (* Unfold definition of &quot;gcd'&quot;. *)
  apply (unfold gcd'_def)

  (* Annoate the loop with an invariant and measure. *)
  apply (subst whileLoop_add_inv [where
     I=&quot;λ(a', b') s. gcd a b = gcd a' b' ∧ P (gcd a b) s&quot;
     and M=&quot;λ((a', b'), s). a'&quot;])

  (* Solve using weakest-precondition. *)
  apply (wp; clarsimp)
   apply (metis gcd.commute gcd_red_nat)
  using gt_or_eq_0 by fastforce
</code></pre><p>这种水平的验证我们暂时还写不出来，大家只要有个概念就好，后面针对常见算法的验证方法我们用到再讲。</p></div><div dir="ltr" class="level article-bar is-mobile"><div class="level-item has-text-centered"><a title="previous page" class="previouse-article-link" href="fv6.html"><span class="icon icon-previous" data-icon="previous"></span><span class="link-content">&laquo; Previous</span></a></div><div class="level-item has-text-centered"><a title="font size" class="link-item link-item-size"><span class="icon icon-size" data-icon="size"></span></a></div><div class="level-item has-text-centered"><a title="table of content" class="link-item link-item-toc"><span class="icon icon-toc" data-icon="toc"></span></a></div><div class="level-item has-text-centered"><a title="top" href="#"><span class="icon icon-up" data-icon="up"></span> <span class="link-content">⤊ Top</span></a></div><div class="level-item has-text-centered"><a title="next page" class="next-article-link" href="fv8.html"><span class="icon icon-next" data-icon="next"></span><span class="link-content">Next &raquo;</span></a></div></div></div><div class="column is-2-widescreen is-hidden"></div></div><div class="columns foot"><div class="column is-3 is-offset-9 build-by">Build by <a href="https://github.com/ruanyf/loppo" target="_blank">Loppo</a> 0.6.20</div></div><div class="book-toc notification is-warning is-hidden"><h3>Table of chapters &nbsp;<span class="title-close"><a class="button is-danger"> Close</a></span></h3><ul class="chapter-area"><li class="chapter-item"><a href="fv1.html">操作系统形式化验证实践教程(1) - 证明第一个定理</a></li><li class="chapter-item"><a href="fv10.html">操作系统形式化验证实践教程(10) - 一阶直觉逻辑</a></li><li class="chapter-item"><a href="fv11.html">操作系统形式化验证实践教程(11) - 结构化证明语言Isar</a></li><li class="chapter-item"><a href="fv12.html">操作系统形式化验证实践教程(12) - 经典命题逻辑与公式查错方法</a></li><li class="chapter-item"><a href="fv13.html">操作系统形式化验证实践教程(13) - 符号的输入方法</a></li><li class="chapter-item"><a href="fv2.html">操作系统形式化验证实践教程(2) - HOL列表与集合</a></li><li class="chapter-item"><a href="fv3.html">操作系统形式化验证实践教程(3) - 自动证明工具</a></li><li class="chapter-item"><a href="fv4.html">操作系统形式化验证实践教程(4) - 工具环境</a></li><li class="chapter-item"><a href="fv5.html">操作系统形式化验证实践教程(5) - 搭建seL4环境</a></li><li class="chapter-item"><a href="fv6.html">操作系统形式化验证实践教程(6) - 解析C源代码</a></li><li class="chapter-item chapter-item-current"><a href="fv7.html">操作系统形式化验证实践教程(7) - C代码的自动验证</a></li><li class="chapter-item"><a href="fv8.html">操作系统形式化验证实践教程(8) - 用Haskell做系统建模</a></li><li class="chapter-item"><a href="fv9.html">操作系统形式化验证实践教程(9) - 规范与证明概述</a></li><li class="chapter-item"><a href="符号执行/index.html">符号执行</a>&nbsp;<a class="first-level-collapse"><span class="icon icon-expand" data-icon="expand"></span></a></li><ul class="chapter-level-1"><li class="chapter-item"><a href="符号执行/ se1.html">符号执行(1) - 自动生成覆盖率用例之利器</a></li></ul></ul></div><div class="progress-indicator"></div><!-- SCRIPTS --><script>var LOPPO={current_path:"fv7.md",relative_root_path:"",article_toc:'<ul class="markdownIt-TOC">\n<li><a href="#autocorres">AutoCorres</a>\n<ul>\n<li><a href="#%E9%80%9A%E8%BF%87by-eval%E9%AA%8C%E8%AF%81%E5%85%B7%E4%BD%93%E4%BE%8B%E5%AD%90">通过by eval验证具体例子</a></li>\n<li><a href="#%E6%BC%94%E7%BB%8E%E9%AA%8C%E8%AF%81">演绎验证</a></li>\n</ul>\n</li>\n<li><a href="#%E8%87%AA%E5%8A%A8%E7%94%9F%E6%88%90%E5%AE%9A%E7%90%86%E5%92%8C%E8%AF%81%E6%98%8E">自动生成定理和证明</a></li>\n<li><a href="#%E9%AA%8C%E8%AF%81%E5%B9%B6%E9%9D%9E%E6%98%AF%E9%87%8D%E5%A4%8D%E4%BB%A3%E7%A0%81%E9%80%BB%E8%BE%91">验证并非是重复代码逻辑</a></li>\n</ul>\n'}</script><script src="assets/js/app.js"></script></body></html>