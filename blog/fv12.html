<!DOCTYPE html><html><head><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta charset="utf-8"><title>操作系统形式化验证实践教程(12) - 经典命题逻辑与公式查错方法 - 哲学系炼金术指南</title><meta name="description" content=""><meta name="author" content=""><meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1,minimum-scale=1"><link rel="stylesheet" href="assets/css/bulma.min.css"><link rel="stylesheet" href="assets/css/app.css"><!--[if lt IE 9]>
<script src="//cdnjs.cloudflare.com/ajax/libs/html5shiv/3.7.2/html5shiv.min.js"></script>
<script src="//cdnjs.cloudflare.com/ajax/libs/respond.js/1.4.2/respond.min.js"></script>
<![endif]--><link rel="shortcut icon" href=""></head><body dir="ltr"><nav class="columns navbar"><div class="column logo is-3 is-offset-1"><a class="is-brand" href="index.html">哲学系炼金术指南</a></div></nav><div class="columns content"><div class="column is-2-desktop is-3-widescreen is-hidden-touch"></div><div class="column article-container is-11-tablet is-8-desktop is-6-widescreen"><div class="breadcrumb-area"><a href="index.html" class="breadcrumb-item">Home</a><span class="breadcrumb-delimiter"> &gt; </span><a href="fv12.html" class="breadcrumb-item">操作系统形式化验证实践教程(12) - 经典命题逻辑与公式查错方法</a></div><h1 class="article-title">操作系统形式化验证实践教程(12) - 经典命题逻辑与公式查错方法</h1><div class="article"><p>第10节我们介绍了直觉一阶逻辑，它是不接受排中律的逻辑。在编程体感上，直觉一阶逻辑IFOL库，不支持auto，不支持sledgehammer，不能使用try0与try，基本上可以使用的就是simp或者手动推理。</p><p>经典命题逻辑我们使用经典一阶逻辑库FOL，它是继承自IFOL的。</p><h2 id="经典一阶逻辑库fol">经典一阶逻辑库FOL <a class="markdownIt-Anchor" href="#经典一阶逻辑库fol">#</a></h2><p>现在我们换成经典一阶逻辑的FOL库，现在可以使用auto了，我们看个例子：</p><pre class="hljs"><code>theory fol2
  imports FOL
begin
lemma D3: &quot;⟦(¬A ⟹ B);(¬A ⟹¬B)⟧⟹ A&quot;
proof (auto)
qed
end
</code></pre><p>我们来个复杂点的例子：</p><pre class="hljs"><code>lemma E1 : 
  assumes 1: ‹¬A ⟶ B›
and 2: ‹¬B›
and 3: ‹¬A›
shows ‹¬B ⟶ A›
</code></pre><p>从一堆公式中取出一个，可以采用local访问的方式，根据下标的不同来进行获取，比如取第n个可以用local.assms(n)，也可以直接local.n，我们看例子：</p><pre class="hljs"><code>lemma E2_1: 
  assumes 1: ‹¬A ⟶ B›
and 2: ‹¬B›
and 3: ‹¬A›
shows ‹¬A ⟶ B›
  by (rule local.assms(1))

lemma E2_2:
  assumes 1: ‹¬A ⟶ B›
and 2: ‹¬B›
and 3: ‹¬A›
shows ‹¬A›
  by (rule local.assms(3))

lemma E2_3:
  assumes 1: ‹¬A ⟶ B›
and 2: ‹¬B›
and 3: ‹¬A›
shows ‹¬B›
  by (rule local.assms(2))
</code></pre><p>于是，按照《面向计算机科学的数理逻辑》中的写法，我们的公式推导可以写成下面这样：</p><pre class="hljs"><code>lemma E1 : 
  assumes 1: ‹¬A ⟶ B›
and 2: ‹¬B›
and 3: ‹¬A›
shows ‹¬B ⟶ A›
proof -
  from &quot;1&quot; &quot;2&quot; &quot;3&quot; have 1: ‹¬A ⟶ B› by (rule E2_1)
  from &quot;1&quot; &quot;2&quot; &quot;3&quot; have 3: ‹¬A› by (rule E2_2)
  from &quot;1&quot; &quot;2&quot; &quot;3&quot; have 2: ‹¬B› by (rule E2_3)
  from &quot;1&quot; &quot;3&quot; have 4: ‹B› by (rule mp)
  from &quot;1&quot; &quot;2&quot; &quot;4&quot; have 5: ‹A› by simp
  from &quot;1&quot; &quot;5&quot; show ‹¬B ⟶ A› by simp
qed
</code></pre><p>其中，from 1 3 have 4的过程是个小三段论：</p><pre class="hljs"><code>proof (prove)
using this:
    ¬ A ⟶ B
    ¬ A

goal (1 subgoal):
 1. B
</code></pre><p>from 1 2 4 have 5，我们单独写个定理试试，有notE, notE', contrapos_np等规则可以用：</p><pre class="hljs"><code>lemma Test1: &quot;⟦(¬A ⟶ B);B;¬B⟧⟹A&quot;
  by (rule contrapos_np)
</code></pre><p>上节我们学习了，如果使用上一条的结论this，可以使用with来简化书写，我们把顺序调整一下：</p><pre class="hljs"><code>lemma E2 : 
  assumes 1: ‹¬A ⟶ B›
and 2: ‹¬B›
and 3: ‹¬A›
shows ‹¬B ⟶ A›
proof -
  from &quot;1&quot; &quot;2&quot; &quot;3&quot; have 1: ‹¬A ⟶ B› by (rule E2_1)
  from &quot;1&quot; &quot;2&quot; &quot;3&quot; have 2: ‹¬B› by (rule E2_3)
  from &quot;1&quot; &quot;2&quot; &quot;3&quot; have 3: ‹¬A› by (rule E2_2)
  with &quot;1&quot; have 4: ‹B› by (rule mp)
  with &quot;1&quot; &quot;2&quot; have 5: ‹A› by simp
  with &quot;1&quot; show ‹¬B ⟶ A› by simp
qed
</code></pre><p>因为我们的assumes其实可以直接使用，我们可以简化一下：</p><pre class="hljs"><code>lemma E2_v2 : 
  assumes 1: ‹¬A ⟶ B›
and 2: ‹¬B›
and 3: ‹¬A›
shows ‹¬B ⟶ A›
proof -
  from &quot;1&quot; &quot;3&quot; have 4: ‹B› by (rule mp)
  with &quot;1&quot; &quot;2&quot; have 5: ‹A› by simp
  with &quot;1&quot; show ‹¬B ⟶ A› by simp
qed
</code></pre><h2 id="常用经典命题逻辑定理">常用经典命题逻辑定理 <a class="markdownIt-Anchor" href="#常用经典命题逻辑定理">#</a></h2><h3 id="蕴含相关定理">蕴含相关定理 <a class="markdownIt-Anchor" href="#蕴含相关定理">#</a></h3><pre class="hljs"><code>lemma H1_1 : &quot;(A⟶B) ⟹ (A⟹B)&quot;
  by(rule mp)

lemma H1_2: &quot;A ⟹ (B⟶A)&quot;
  by simp

lemma H1_3: &quot;⟦A⟶B; B⟶C⟧ ⟹ (A⟶C)&quot;
  by simp

lemma H1_4: &quot;⟦A⟶(B⟶C);A⟶B⟧⟹(A⟶C)&quot;
  by simp
</code></pre><p>除了可以用mp证明的第一条，其余三条在直觉逻辑IFOL中都没有证明。mp在IFOL中有实现。</p><h3 id="反证法相关定理">反证法相关定理 <a class="markdownIt-Anchor" href="#反证法相关定理">#</a></h3><p>经典逻辑与直觉逻辑最大的不同就是可以使用反证法了。</p><pre class="hljs"><code>lemma H2_1: &quot;¬¬A ⟹ A&quot;
  by (rule notnotD)

lemma H2_2: &quot;⟦(S⟹A) ⟹ B;(S⟹A) ⟹ ¬B⟧ ⟹ (S ⟹ ¬A)&quot; 
  by auto

lemma H2_3: &quot;A ⟹ ¬¬A&quot;
  by (rule HOL.cnf.clause2raw_not_not)

lemma H2_4: &quot;A⟹¬A ⟹ B&quot;
  by (rule notE)

lemma H2_5: &quot;A ⟹ (¬A ⟶ B)&quot;
  by simp

lemma H2_6: &quot;¬A ⟹ (A⟶B)&quot;
  by simp
</code></pre><p>这几条中，notE在IFOL中有实现，其余都不能用于IFOL.</p><h3 id="逆推相关定理">逆推相关定理 <a class="markdownIt-Anchor" href="#逆推相关定理">#</a></h3><pre class="hljs"><code>lemma H3_1: &quot;(A⟶B) ⟹ (¬B ⟶ ¬A)&quot;
  by (rule Set.not_mono)

lemma H3_2: &quot;(A⟶¬B) ⟹ (B ⟶ ¬A)&quot;
  by auto

lemma H3_3: &quot;(¬A⟶B) ⟹ (¬B ⟶ A)&quot;
  by auto

lemma H3_4: &quot;(¬A ⟶ ¬B) ⟹ (B ⟶ A)&quot;
  by auto
</code></pre><h3 id="化简相关定理">化简相关定理 <a class="markdownIt-Anchor" href="#化简相关定理">#</a></h3><pre class="hljs"><code>lemma H4_1: &quot;(¬A ⟶ A) ⟹ A&quot;
  by (rule imp_elim)

lemma H4_2: &quot;(A ⟶ ¬A) ⟹ ¬A&quot;
  by(rule impCE)

lemma H4_3: &quot;⟦(A⟶B); (A⟶¬B)⟧ ⟹ ¬A&quot;
  by simp

lemma H4_4: &quot;⟦(A⟶B); (¬A⟶B)⟧ ⟹ B&quot;
  by auto

lemma H4_5: &quot;¬(A⟶B) ⟹ A&quot;
  by simp

lemma H4_6: &quot;¬(A⟶B) ⟹ ¬B&quot;
  by simp
</code></pre><h3 id="合取相关定理">合取相关定理 <a class="markdownIt-Anchor" href="#合取相关定理">#</a></h3><pre class="hljs"><code>lemma H5_1: &quot;A∧B ⟹ (A ⟹ B)&quot;
  by(rule conjE)

lemma H5_2: &quot;⟦A;B⟧ ⟹ A∧B&quot;
  by (rule conjI)

lemma H5_3: &quot;(A ∧ B) ⟹ (B ∧ A) &quot;
  by simp

lemma H5_4: &quot;(A∧B)∧C ⟹ A∧(B∧C)&quot;
  by simp

lemma H5_5: &quot;¬(A∧B) ⟹ (A⟶¬B)&quot;
  by simp

lemma H5_6: &quot;¬(A⟶B) ⟹ (A ∧ ¬B)&quot;
  by (rule Meson.not_impD)
</code></pre><p>最后一个H5_6，也可以写成by meson:</p><pre class="hljs"><code>lemma H5_6: &quot;¬(A⟶B) ⟹ (A ∧ ¬B)&quot;
  by meson
</code></pre><h2 id="经典命题逻辑的公理推演系统">经典命题逻辑的公理推演系统 <a class="markdownIt-Anchor" href="#经典命题逻辑的公理推演系统">#</a></h2><p>公理推演系统与自然推理系统是等价的，我们可以用公理推演系统的方法定义推理定理：</p><pre class="hljs"><code>lemma Ax1: &quot;A⟶(B⟶A)&quot;
  by simp

lemma Ax2: &quot;(A⟶(B⟶C)) ⟶ ((A⟶B)⟶(A⟶C))&quot;
  by simp

lemma Ax3: &quot;(¬A ⟶ B)⟶((¬A ⟶ ¬B)⟶A)&quot;
  by simp

lemma Ax4: &quot;A∧B ⟶ A&quot;
  by simp

lemma Ax5: &quot;A∧B ⟶ B&quot;
  by simp

lemma Ax6: &quot;A ⟶ (B⟶ A∧B)&quot;
  by simp

lemma Ax7: &quot;A⟶A∨B&quot;
  by simp

lemma Ax8: &quot;A ⟶ B∨A&quot;
  by simp

lemma Ax9: &quot;(A⟶C) ⟶ ((B⟶C)⟶(A∨B⟶C))&quot;
  by auto

lemma Ax10: &quot;(A⟷B)⟶(A⟶B)&quot;
  by simp

lemma Ax11: &quot;(A⟷B) ⟶ (B⟶A)&quot;
  by simp

lemma Ax12: &quot;(A⟶B) ⟶ ((B⟶A)⟶(A⟷B))&quot;
  by auto
</code></pre><p>其中需要注意的是Ax9，在FOL中需要使用auto, simp无法识别，但在HOL中可以使用simp.</p><h2 id="如何查找反例">如何查找反例 <a class="markdownIt-Anchor" href="#如何查找反例">#</a></h2><p>不知道大家淹没在公式的海洋中的体验如何，反正我写的时候经常写出错误的公式来。<br>这时候我们需要的不是证明，而是先让系统帮我们搜索一下是不是有反例，我们的公式是不是写错了。</p><h3 id="quickcheck">quickcheck <a class="markdownIt-Anchor" href="#quickcheck">#</a></h3><p>检查错误的第一个方法是使用quickcheck，直接当成语句写在IDE中即可。<br>比如Ax12被我们写错了，写成Ax12_2这样子：</p><pre class="hljs"><code>lemma Ax12: &quot;(A⟶B) ⟶ ((B⟶A)⟶(A⟷B))&quot;
  by auto

lemma Ax12_2: &quot;(A⟶B) ⟶ ((A⟶B)⟶(A⟷B))&quot;
  quickcheck
</code></pre><p>系统就会给我们找一个反例：A=False, B=True</p><pre class="hljs"><code>Testing conjecture with Quickcheck-exhaustive... 
Quickcheck found a counterexample:
  A = False
  B = True
</code></pre><p>quickcheck的结果会弹对话框，同时在output窗口显示出来：</p><figure><img src="https://upload-images.jianshu.io/upload_images/1638145-f6d567f025cb775d.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""><figcaption>quickcheck</figcaption></figure><h3 id="nitpick">nitpick <a class="markdownIt-Anchor" href="#nitpick">#</a></h3><p>就像寻找定理证明方法可以用sledgehammer一样，检查反例也有专门的强大工具叫做nitpick。<br>用法和quickcheck一样，在定理后面写一句nitpick就好：<br><img src="https://upload-images.jianshu.io/upload_images/1638145-afe672c39a2ac00c.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="nitpick"></p><p>nitpick作为专门的工具，配置项有很多，我们后面会详细介绍，这里大家先把它和quickcheck用起来。<br>如果公式已经错了，就不用为难sledgehammer去找证明了，先看看哪里写错了。</p><h2 id="小结">小结 <a class="markdownIt-Anchor" href="#小结">#</a></h2><p>不管是自然推理系统还是公理推演系统，在FOL和HOL证明定理时我们并不是用公理和推演规则进行推演的。公理和推演规则一般不对应FOL和HOL的公式，而是需要使用simp甚至auto进行证明的定理。<br>但是，我们还是可以按照我们在数理逻辑中所学的方法进行思考和推演，然后使用HOL的工具帮助我们简化推理的过程，尤其是nitpick等查错工具和sledgehammer等定理搜索工具。</p></div><div dir="ltr" class="level article-bar is-mobile"><div class="level-item has-text-centered"><a title="previous page" class="previouse-article-link" href="fv11.html"><span class="icon icon-previous" data-icon="previous"></span><span class="link-content">&laquo; Previous</span></a></div><div class="level-item has-text-centered"><a title="font size" class="link-item link-item-size"><span class="icon icon-size" data-icon="size"></span></a></div><div class="level-item has-text-centered"><a title="table of content" class="link-item link-item-toc"><span class="icon icon-toc" data-icon="toc"></span></a></div><div class="level-item has-text-centered"><a title="top" href="#"><span class="icon icon-up" data-icon="up"></span> <span class="link-content">⤊ Top</span></a></div><div class="level-item has-text-centered"><a title="next page" class="next-article-link" href="fv13.html"><span class="icon icon-next" data-icon="next"></span><span class="link-content">Next &raquo;</span></a></div></div></div><div class="column is-2-widescreen is-hidden"></div></div><div class="columns foot"><div class="column is-3 is-offset-9 build-by">Build by <a href="https://github.com/ruanyf/loppo" target="_blank">Loppo</a> 0.6.20</div></div><div class="book-toc notification is-warning is-hidden"><h3>Table of chapters &nbsp;<span class="title-close"><a class="button is-danger"> Close</a></span></h3><ul class="chapter-area"><li class="chapter-item"><a href="fv1.html">操作系统形式化验证实践教程(1) - 证明第一个定理</a></li><li class="chapter-item"><a href="fv10.html">操作系统形式化验证实践教程(10) - 一阶直觉逻辑</a></li><li class="chapter-item"><a href="fv11.html">操作系统形式化验证实践教程(11) - 结构化证明语言Isar</a></li><li class="chapter-item chapter-item-current"><a href="fv12.html">操作系统形式化验证实践教程(12) - 经典命题逻辑与公式查错方法</a></li><li class="chapter-item"><a href="fv13.html">操作系统形式化验证实践教程(13) - 符号的输入方法</a></li><li class="chapter-item"><a href="fv2.html">操作系统形式化验证实践教程(2) - HOL列表与集合</a></li><li class="chapter-item"><a href="fv3.html">操作系统形式化验证实践教程(3) - 自动证明工具</a></li><li class="chapter-item"><a href="fv4.html">操作系统形式化验证实践教程(4) - 工具环境</a></li><li class="chapter-item"><a href="fv5.html">操作系统形式化验证实践教程(5) - 搭建seL4环境</a></li><li class="chapter-item"><a href="fv6.html">操作系统形式化验证实践教程(6) - 解析C源代码</a></li><li class="chapter-item"><a href="fv7.html">操作系统形式化验证实践教程(7) - C代码的自动验证</a></li><li class="chapter-item"><a href="fv8.html">操作系统形式化验证实践教程(8) - 用Haskell做系统建模</a></li><li class="chapter-item"><a href="fv9.html">操作系统形式化验证实践教程(9) - 规范与证明概述</a></li></ul></div><div class="progress-indicator"></div><!-- SCRIPTS --><script>var LOPPO={current_path:"fv12.md",relative_root_path:"",article_toc:'<ul class="markdownIt-TOC">\n<li><a href="#%E7%BB%8F%E5%85%B8%E4%B8%80%E9%98%B6%E9%80%BB%E8%BE%91%E5%BA%93fol">经典一阶逻辑库FOL</a></li>\n<li><a href="#%E5%B8%B8%E7%94%A8%E7%BB%8F%E5%85%B8%E5%91%BD%E9%A2%98%E9%80%BB%E8%BE%91%E5%AE%9A%E7%90%86">常用经典命题逻辑定理</a>\n<ul>\n<li><a href="#%E8%95%B4%E5%90%AB%E7%9B%B8%E5%85%B3%E5%AE%9A%E7%90%86">蕴含相关定理</a></li>\n<li><a href="#%E5%8F%8D%E8%AF%81%E6%B3%95%E7%9B%B8%E5%85%B3%E5%AE%9A%E7%90%86">反证法相关定理</a></li>\n<li><a href="#%E9%80%86%E6%8E%A8%E7%9B%B8%E5%85%B3%E5%AE%9A%E7%90%86">逆推相关定理</a></li>\n<li><a href="#%E5%8C%96%E7%AE%80%E7%9B%B8%E5%85%B3%E5%AE%9A%E7%90%86">化简相关定理</a></li>\n<li><a href="#%E5%90%88%E5%8F%96%E7%9B%B8%E5%85%B3%E5%AE%9A%E7%90%86">合取相关定理</a></li>\n</ul>\n</li>\n<li><a href="#%E7%BB%8F%E5%85%B8%E5%91%BD%E9%A2%98%E9%80%BB%E8%BE%91%E7%9A%84%E5%85%AC%E7%90%86%E6%8E%A8%E6%BC%94%E7%B3%BB%E7%BB%9F">经典命题逻辑的公理推演系统</a></li>\n<li><a href="#%E5%A6%82%E4%BD%95%E6%9F%A5%E6%89%BE%E5%8F%8D%E4%BE%8B">如何查找反例</a>\n<ul>\n<li><a href="#quickcheck">quickcheck</a></li>\n<li><a href="#nitpick">nitpick</a></li>\n</ul>\n</li>\n<li><a href="#%E5%B0%8F%E7%BB%93">小结</a></li>\n</ul>\n'}</script><script src="assets/js/app.js"></script></body></html>