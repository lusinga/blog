<!DOCTYPE html><html><head><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta charset="utf-8"><title>符号执行(1) - 自动生成覆盖率用例之利器 - 哲学系炼金术士</title><meta name="description" content=""><meta name="author" content=""><meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1,minimum-scale=1"><link rel="stylesheet" href="../assets/css/bulma.min.css"><link rel="stylesheet" href="../assets/css/app.css"><!--[if lt IE 9]>
<script src="//cdnjs.cloudflare.com/ajax/libs/html5shiv/3.7.2/html5shiv.min.js"></script>
<script src="//cdnjs.cloudflare.com/ajax/libs/respond.js/1.4.2/respond.min.js"></script>
<![endif]--><link rel="shortcut icon" href=""></head><body dir="ltr"><nav class="columns navbar"><div class="column logo is-3 is-offset-1"><a class="is-brand" href="../index.html">哲学系炼金术士</a></div></nav><div class="columns content"><div class="column is-2-desktop is-3-widescreen is-hidden-touch"></div><div class="column article-container is-11-tablet is-8-desktop is-6-widescreen"><div class="breadcrumb-area"><a href="../index.html" class="breadcrumb-item">Home</a><span class="breadcrumb-delimiter"> &gt; </span><a href="../符号执行/index.html" class="breadcrumb-item">符号执行</a><span class="breadcrumb-delimiter"> &gt; </span><a href="../符号执行/ se1.html" class="breadcrumb-item">符号执行(1) - 自动生成覆盖率用例之利器</a></div><h1 class="article-title">符号执行(1) - 自动生成覆盖率用例之利器</h1><div class="article"><p>对于安全性要求比较高的软件，为了防止出现安全漏洞，我们不得不花大量时间写更多的测试用例来提升覆盖率。尤其是高可靠性软件需要的修正条件判定覆盖MC/DC(Modified Condition/Decision Coverage)，更是要多花不少心思。</p><p>全靠手工写，工作量太大，而且重复性工作不少。靠模糊测试命中的话效率又比较低。<br>那么，有没有什么办法可以将这些机械的工作做得自动化一点，机器能够帮我们设计一些测试用例呢？符号执行就是一种可用的利器。</p><h2 id="什么是符号执行">什么是符号执行 <a class="markdownIt-Anchor" href="#什么是符号执行">#</a></h2><p>为了避免有同学望文生义，我们先解释下符号执行的含义。符号执行是借助程序的形式化语义来分析代码的一种方法，具体地说，不考虑循环的情况下，符号执行就是求解霍尔逻辑的最弱前置条件。<br>这里面主要的工具除了霍尔逻辑的公理外，主要还会用到可满足性模理论SMT工具。后面我们讲符号执行工具klee时大家就会看到，相当多的步骤其实我们是在准备SMT工具。</p><p>有个简单的概念之后，我们迅速进入通过例子学习的阶段。对于跟安全性打交道不多的同学来说，完全不懂Hoare Logic, SMT, SAT这些概念不影响使用符号执行工具来帮我们找出一些测试用例。</p><h2 id="通过例子学习klee符号执行">通过例子学习klee符号执行 <a class="markdownIt-Anchor" href="#通过例子学习klee符号执行">#</a></h2><p>下面我们就以klee为例来讲解下如何在工作中使用符号执行来帮我们生成测试用例。</p><p>klee是用于C/C++的符号执行工具，也有达人研究中应用于Rust等语言的用法。通过后面的例子可以看到，只要能生成llvm byte code，应该都有办法来执行。</p><p>我们先写个待测函数，将百分制的分数映射成ABCD等级：</p><pre class="hljs"><code><span class="hljs-function"><span class="hljs-keyword">char</span> <span class="hljs-title">testscore</span><span class="hljs-params">(<span class="hljs-keyword">int</span> score)</span>
</span>{
    <span class="hljs-keyword">if</span> (score &gt; <span class="hljs-number">100</span>)
    {
        <span class="hljs-keyword">return</span> <span class="hljs-string">&#x27;E&#x27;</span>;
    }
    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (score &lt; <span class="hljs-number">0</span>)
    {
        <span class="hljs-keyword">return</span> <span class="hljs-string">&#x27;E&#x27;</span>;
    }
    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (score &gt;= <span class="hljs-number">90</span>)
    {
        <span class="hljs-keyword">return</span> <span class="hljs-string">&#x27;A&#x27;</span>;
    }
    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (score &gt;= <span class="hljs-number">80</span>)
    {
        <span class="hljs-keyword">return</span> <span class="hljs-string">&#x27;B&#x27;</span>;
    }
    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (score &gt;= <span class="hljs-number">60</span>)
    {
        <span class="hljs-keyword">return</span> <span class="hljs-string">&#x27;C&#x27;</span>;
    }
    <span class="hljs-keyword">else</span>
    {
        <span class="hljs-keyword">return</span> <span class="hljs-string">&#x27;D&#x27;</span>;
    }
}
</code></pre><p>既然是符号执行，我们写测试用例时不给具体值，只给一个符号，然后让klee帮我们去找该测什么值。这通过klee_make_symbolic函数来实现，我们给上面的testscore写个main函数来调用：</p><pre class="hljs"><code><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span>
</span>{
    <span class="hljs-keyword">int</span> score;
    klee_make_symbolic(&amp;score, <span class="hljs-keyword">sizeof</span>(score), <span class="hljs-string">&quot;score&quot;</span>);
    <span class="hljs-keyword">return</span> (testscore(score));
}
</code></pre><p>我们用clang来编译它，生成llvm中间代码testscore.bc:</p><pre class="hljs"><code>clang -emit-llvm -c testscore.c
</code></pre><p>然后我们就调用klee去自动执行上一步编译出的字节码:</p><pre class="hljs"><code>klee testscore.bc
</code></pre><p>输出如下：</p><pre class="hljs"><code>KLEE: output directory is &quot;/workspace/xulun/github/libs/klee-out-3&quot;
KLEE: Using STP solver backend

KLEE: done: total instructions = 61
KLEE: done: completed paths = 6
KLEE: done: generated tests = 6
</code></pre><p>以上说明，总共61条指令，klee为我们发现了6个分支，并生成了覆盖这6个分支的测试用例。</p><p>我们通过klee-stats工具来看下生成的用例的覆盖率：</p><pre class="hljs"><code>----------------------------------------------------------------------------
|    Path     |  Instrs|  Time(s)|  ICov(%)|  BCov(%)|  ICount|  TSolver(%)|
----------------------------------------------------------------------------
|./klee-out-3/|      61|     0.05|   100.00|   100.00|      41|       96.17|
----------------------------------------------------------------------------
</code></pre><p>我们看到，语句和分支的覆盖率都是100%，干得不错。</p><p>下面我们用ktest-tool工具来看下生成的6个测试用例的值是什么：</p><pre class="hljs"><code>ktest-tool ./klee-out-3/test000001.ktest
ktest file : './klee-out-3/test000001.ktest'
args       : ['testscore.bc']
num objects: 1
object 0: name: 'score'
object 0: size: 4
object 0: data: b'\xff\xff\xff\x7f'
object 0: hex : 0xffffff7f
object 0: int : 2147483647
object 0: uint: 2147483647
object 0: text: ....
[root@7a5293f64325 libs]# ktest-tool ./klee-out-3/test000002.ktest
ktest file : './klee-out-3/test000002.ktest'
args       : ['testscore.bc']
num objects: 1
object 0: name: 'score'
object 0: size: 4
object 0: data: b'\x00\x00\x00\x80'
object 0: hex : 0x00000080
object 0: int : -2147483648
object 0: uint: 2147483648
object 0: text: ....
[root@7a5293f64325 libs]# ktest-tool ./klee-out-3/test000003.ktest
ktest file : './klee-out-3/test000003.ktest'
args       : ['testscore.bc']
num objects: 1
object 0: name: 'score'
object 0: size: 4
object 0: data: b'\x00\x00\x00\x00'
object 0: hex : 0x00000000
object 0: int : 0
object 0: uint: 0
object 0: text: ....
[root@7a5293f64325 libs]# ktest-tool ./klee-out-3/test000004.ktest
ktest file : './klee-out-3/test000004.ktest'
args       : ['testscore.bc']
num objects: 1
object 0: name: 'score'
object 0: size: 4
object 0: data: b'Z\x00\x00\x00'
object 0: hex : 0x5a000000
object 0: int : 90
object 0: uint: 90
object 0: text: Z...
[root@7a5293f64325 libs]# ktest-tool ./klee-out-3/test000005.ktest
ktest file : './klee-out-3/test000005.ktest'
args       : ['testscore.bc']
num objects: 1
object 0: name: 'score'
object 0: size: 4
object 0: data: b'&lt;\x00\x00\x00'
object 0: hex : 0x3c000000
object 0: int : 60
object 0: uint: 60
object 0: text: &lt;...
[root@7a5293f64325 libs]# ktest-tool ./klee-out-3/test000006.ktest
ktest file : './klee-out-3/test000006.ktest'
args       : ['testscore.bc']
num objects: 1
object 0: name: 'score'
object 0: size: 4
object 0: data: b'P\x00\x00\x00'
object 0: hex : 0x50000000
object 0: int : 80
object 0: uint: 80
object 0: text: P...
</code></pre><p>通过读取test000001.ktest到test000006.ktest这6个文件，我们发现，系统帮我们找到的score值分别为：2147483647，-2147483648，0，90，60，80。最大正值，最小负值和0都被考虑到了，还有代码中区分不同分支的60,80,90都被自动找到了。</p><h2 id="两个参数的例子">两个参数的例子 <a class="markdownIt-Anchor" href="#两个参数的例子">#</a></h2><p>单找一个参数不过瘾，我们再来试试两个参数的。<br>先来个最简单的，求两个数的最大值吧：</p><pre class="hljs"><code><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&quot;klee/klee.h&quot;</span></span>

<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">max2</span><span class="hljs-params">(<span class="hljs-keyword">int</span> a, <span class="hljs-keyword">int</span> b)</span></span>{
    <span class="hljs-keyword">if</span>(a&gt;b){
        <span class="hljs-keyword">return</span> a;
    }<span class="hljs-keyword">else</span>{
        <span class="hljs-keyword">return</span> b;
    }
}

<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span>
</span>{
    <span class="hljs-keyword">int</span> a,b;
    klee_make_symbolic(&amp;a, <span class="hljs-keyword">sizeof</span>(a), <span class="hljs-string">&quot;a&quot;</span>);
    klee_make_symbolic(&amp;b, <span class="hljs-keyword">sizeof</span>(b), <span class="hljs-string">&quot;b&quot;</span>);
    <span class="hljs-keyword">return</span> (max2(a,b));
}
</code></pre><p>老办法，编译成bc字节码：</p><pre class="hljs"><code>clang -emit-llvm -c max.c
</code></pre><p>然后运行klee max.bc:</p><pre class="hljs"><code>klee max.bc
KLEE: output directory is &quot;/workspace/xulun/github/libs/klee-out-4&quot;
KLEE: Using STP solver backend

KLEE: done: total instructions = 32
KLEE: done: completed paths = 2
KLEE: done: generated tests = 2
</code></pre><p>这个只有两个分支，所以klee给我们也就找到两个。<br>再用klee-stats看下覆盖率：</p><pre class="hljs"><code># klee-stats ./klee-out-4/
----------------------------------------------------------------------------
|    Path     |  Instrs|  Time(s)|  ICov(%)|  BCov(%)|  ICount|  TSolver(%)|
----------------------------------------------------------------------------
|./klee-out-4/|      32|     0.00|   100.00|   100.00|      29|       65.62|
----------------------------------------------------------------------------
</code></pre><h2 id="带循环的例子">带循环的例子 <a class="markdownIt-Anchor" href="#带循环的例子">#</a></h2><p>下面我们再挑战个复杂点的例子，带循环结构的例子。<br>我们以辗转相除法求最大公约数为例子吧：</p><pre class="hljs"><code><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&quot;klee/klee.h&quot;</span></span>

<span class="hljs-function"><span class="hljs-keyword">short</span> <span class="hljs-title">gcd</span><span class="hljs-params">(<span class="hljs-keyword">short</span> a, <span class="hljs-keyword">short</span> b)</span></span>{
    <span class="hljs-keyword">short</span> a0 = a;
    <span class="hljs-keyword">short</span> b0 = b;
    <span class="hljs-keyword">short</span> c0 = <span class="hljs-number">0</span>;
    <span class="hljs-keyword">if</span>(a&lt;=<span class="hljs-number">0</span> || b&lt;=<span class="hljs-number">0</span>){
        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
    }

    <span class="hljs-keyword">if</span>(a&lt;b){
        a0 = b;
        b0 = a;
    }

    <span class="hljs-keyword">for</span>(;;){
        c0 = a0 % b0;
        <span class="hljs-keyword">if</span>(c0==<span class="hljs-number">0</span>){
            <span class="hljs-keyword">return</span> b0;
        }<span class="hljs-keyword">else</span>{
            a0 = b0;
            b0 = c0;
        }
    }

    <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;
}

<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span>
</span>{
    <span class="hljs-keyword">short</span> a,b;
    klee_make_symbolic(&amp;a, <span class="hljs-keyword">sizeof</span>(a), <span class="hljs-string">&quot;a&quot;</span>);
    klee_make_symbolic(&amp;b, <span class="hljs-keyword">sizeof</span>(b), <span class="hljs-string">&quot;b&quot;</span>);
    <span class="hljs-keyword">return</span> (gcd(a,b));
}
</code></pre><p>大家看到，这个例子我们没用int类型，而是使用的short，这样是因为int需要运行的时间较长，光short类型klee就为我们发现了44个case，大约会占满一个CPU核几分钟左右。</p><pre class="hljs"><code>klee gcd2.bc
KLEE: output directory is &quot;/workspace/xulun/github/libs/klee-out-5&quot;
KLEE: Using STP solver backend

KLEE: done: total instructions = 1431
KLEE: done: completed paths = 44
KLEE: done: generated tests = 44
</code></pre><p>我们看下coverage:</p><pre class="hljs"><code># klee-stats ./klee-out-5/
----------------------------------------------------------------------------
|    Path     |  Instrs|  Time(s)|  ICov(%)|  BCov(%)|  ICount|  TSolver(%)|
----------------------------------------------------------------------------
|./klee-out-5/|    1431|   212.26|    98.75|    90.00|      80|       99.99|
----------------------------------------------------------------------------
</code></pre><p>因为这个是测试最大公约数，klee能够帮助我们生成例子能帮我们省不少事。<br>因为a和b都是0的case已经可以cover到a&lt;=0 || b&lt;=0这一分支，所以klee除了第一个case是0，0之外，后面全是正的有效例子。<br>第一个是0,0:</p><pre class="hljs"><code>ktest-tool ./klee-out-6/test000001.ktest
ktest file : './klee-out-6/test000001.ktest'
args       : ['gcd3.bc']
num objects: 2
object 0: name: 'a'
object 0: size: 2
object 0: data: b'\x00\x00'
object 0: hex : 0x0000
object 0: int : 0
object 0: uint: 0
object 0: text: ..
object 1: name: 'b'
object 1: size: 2
object 1: data: b'\x00\x00'
object 1: hex : 0x0000
object 1: int : 0
object 1: uint: 0
object 1: text: ..
</code></pre><p>全部44次的值如下：</p><table><thead><tr><th>轮数</th><th>a</th><th>b</th></tr></thead><tbody><tr><td>1</td><td>0</td><td>0</td></tr><tr><td>2</td><td>1</td><td>0</td></tr><tr><td>3</td><td>1</td><td>1</td></tr><tr><td>4</td><td>1</td><td>3</td></tr><tr><td>5</td><td>2</td><td>3</td></tr><tr><td>6</td><td>2559</td><td>2</td></tr><tr><td>7</td><td>5</td><td>7</td></tr><tr><td>8</td><td>31317</td><td>65</td></tr><tr><td>9</td><td>4102</td><td>16405</td></tr><tr><td>10</td><td>20482</td><td>12289</td></tr><tr><td>11</td><td>6573</td><td>8204</td></tr><tr><td>12</td><td>32601</td><td>143</td></tr><tr><td>13</td><td>2589</td><td>6038</td></tr><tr><td>14</td><td>32511</td><td>4192</td></tr><tr><td>15</td><td>3783</td><td>16384</td></tr><tr><td>16</td><td>20610</td><td>11838</td></tr><tr><td>17</td><td>21524</td><td>28799</td></tr><tr><td>18</td><td>22774</td><td>1444</td></tr><tr><td>19</td><td>24704</td><td>31937</td></tr><tr><td>20</td><td>24587</td><td>16044</td></tr><tr><td>21</td><td>25961</td><td>26699</td></tr><tr><td>22</td><td>19805</td><td>17422</td></tr><tr><td>23</td><td>23516</td><td>25899</td></tr><tr><td>24</td><td>13077</td><td>7540</td></tr><tr><td>25</td><td>18653</td><td>28171</td></tr><tr><td>26</td><td>32577</td><td>20000</td></tr><tr><td>27</td><td>19932</td><td>32107</td></tr><tr><td>28</td><td>32622</td><td>26737</td></tr><tr><td>29</td><td>19290</td><td>26657</td></tr><tr><td>30</td><td>27009</td><td>16386</td></tr><tr><td>31</td><td>19074</td><td>29917</td></tr><tr><td>32</td><td>23467</td><td>32422</td></tr><tr><td>33</td><td>28266</td><td>17443</td></tr><tr><td>34</td><td>19584</td><td>31685</td></tr><tr><td>35</td><td>31505</td><td>19452</td></tr><tr><td>36</td><td>29779</td><td>18406</td></tr><tr><td>37</td><td>15413</td><td>24939</td></tr><tr><td>38</td><td>25829</td><td>15969</td></tr><tr><td>39</td><td>28655</td><td>17709</td></tr><tr><td>40</td><td>20041</td><td>32428</td></tr><tr><td>41</td><td>15841</td><td>25631</td></tr><tr><td>42</td><td>25633</td><td>15842</td></tr><tr><td>43</td><td>17711</td><td>28657</td></tr><tr><td>44</td><td>28657</td><td>17711</td></tr></tbody></table><h2 id="数组和字符串的例子">数组和字符串的例子 <a class="markdownIt-Anchor" href="#数组和字符串的例子">#</a></h2><p>我们来个字符串的例子，因为不是测库函数，所以没有调用库函数。其实klee_make_symbolic本来就是为数组设计的，我们只要把数组大小传给第2个参数就可以了：</p><pre class="hljs"><code><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&quot;klee/klee.h&quot;</span></span>

<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">check_pass</span><span class="hljs-params">(<span class="hljs-keyword">char</span>* a)</span></span>{
    <span class="hljs-keyword">if</span>(a==<span class="hljs-literal">NULL</span>){
        <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;
    }<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(a[<span class="hljs-number">0</span>]==<span class="hljs-string">&#x27;\0&#x27;</span>){
        <span class="hljs-keyword">return</span> <span class="hljs-number">-2</span>;
    }<span class="hljs-keyword">else</span>{
        <span class="hljs-keyword">if</span>(a[<span class="hljs-number">0</span>]==<span class="hljs-string">&#x27;C&#x27;</span> &amp;&amp; a[<span class="hljs-number">1</span>]==<span class="hljs-string">&#x27;+&#x27;</span> &amp;&amp; a[<span class="hljs-number">2</span>]==<span class="hljs-string">&#x27;+&#x27;</span>){
            <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;
        }<span class="hljs-keyword">else</span>{
            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
        }
    }
}

<span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> LEN 3</span>

<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span>
</span>{
    <span class="hljs-keyword">char</span> secret[LEN];
    klee_make_symbolic(&amp;secret, LEN, <span class="hljs-string">&quot;secret&quot;</span>);
    <span class="hljs-keyword">return</span> (check_pass(secret));
}
</code></pre><p>klee为我们找到5个分支，分别是：0开头的，非0非C开头的，C开头的, C+开头的, C++ 5种：</p><pre class="hljs"><code>[root@7a5293f64325 libs]# ktest-tool ./klee-out-7/test000001.ktest
ktest file : './klee-out-7/test000001.ktest'
args       : ['strc.bc']
num objects: 1
object 0: name: 'secret'
object 0: size: 3
object 0: data: b'\x00\x00\x00'
object 0: hex : 0x000000
object 0: text: ...
[root@7a5293f64325 libs]# ktest-tool ./klee-out-7/test000002.ktest
ktest file : './klee-out-7/test000002.ktest'
args       : ['strc.bc']
num objects: 1
object 0: name: 'secret'
object 0: size: 3
object 0: data: b'\x01\xff\xff'
object 0: hex : 0x01ffff
object 0: text: ...
[root@7a5293f64325 libs]# ktest-tool ./klee-out-7/test000003.ktest
ktest file : './klee-out-7/test000003.ktest'
args       : ['strc.bc']
num objects: 1
object 0: name: 'secret'
object 0: size: 3
object 0: data: b'C\x00\xff'
object 0: hex : 0x4300ff
object 0: text: C..
[root@7a5293f64325 libs]# ktest-tool ./klee-out-7/test000004.ktest
ktest file : './klee-out-7/test000004.ktest'
args       : ['strc.bc']
num objects: 1
object 0: name: 'secret'
object 0: size: 3
object 0: data: b'C+\x00'
object 0: hex : 0x432b00
object 0: text: C+.
[root@7a5293f64325 libs]# ktest-tool ./klee-out-7/test000005.ktest
ktest file : './klee-out-7/test000005.ktest'
args       : ['strc.bc']
num objects: 1
object 0: name: 'secret'
object 0: size: 3
object 0: data: b'C++'
object 0: hex : 0x432b2b
object 0: text: C++
</code></pre><h2 id="编译安装klee">编译安装klee <a class="markdownIt-Anchor" href="#编译安装klee">#</a></h2><p>展示了klee的能力之后，很多同学跃跃欲试想一试身手了。建议初试身手时在ubuntu Linux上尝试。</p><p>klee因为其复杂性，依赖比较多。除了llvm,cmake之类的通用依赖之外，我们还需要为其编译SAT求解器minisat和SMT求解器stp。</p><p>为了让文章简单，下面的步骤都取了极简的步骤。后面我们还会编译更复杂依赖的klee。</p><h3 id="下载编译minisat">下载编译minisat <a class="markdownIt-Anchor" href="#下载编译minisat">#</a></h3><p>minisat是一种SAT-布尔可满足性理论求解器。后面会介绍SAT的原理，包括DPLL, CDCL方法等。</p><pre class="hljs"><code>git clone https://github.com/stp/minisat.git
cd minisat
mkdir build
cd build
sudo make install
</code></pre><h3 id="下载编译stp">下载编译stp <a class="markdownIt-Anchor" href="#下载编译stp">#</a></h3><p>STP是基于minisat的SMT-可满足性模理论求解器。</p><pre class="hljs"><code>git clone https://github.com/stp/stp.git
cd stp
mkdir build
cd build
cmake ..
make
sudo make install
</code></pre><h3 id="下载编译klee">下载编译klee <a class="markdownIt-Anchor" href="#下载编译klee">#</a></h3><p>下面是极简步骤，后面我们还会增加库和加上测试。</p><pre class="hljs"><code>git clone https://github.com/klee/klee.git
mkdir build
cd build
cmake -DENABLE_UNIT_TESTS=OFF -DENABLE_SYSTEM_TESTS=OFF ..
make
sudo make install
</code></pre><p>好了，现在klee命令可用了，大家就可以用自己的代码做实验了：）</p></div><div dir="ltr" class="level article-bar is-mobile"><div class="level-item has-text-centered"><a title="previous page" class="previouse-article-link" href="../符号执行/index.html"><span class="icon icon-previous" data-icon="previous"></span><span class="link-content">&laquo; Previous</span></a></div><div class="level-item has-text-centered"><a title="font size" class="link-item link-item-size"><span class="icon icon-size" data-icon="size"></span></a></div><div class="level-item has-text-centered"><a title="table of content" class="link-item link-item-toc"><span class="icon icon-toc" data-icon="toc"></span></a></div><div class="level-item has-text-centered"><a title="top" href="#"><span class="icon icon-up" data-icon="up"></span> <span class="link-content">⤊ Top</span></a></div><div class="level-item has-text-centered"><a title="next page" class="next-article-link link-disabled"><span class="icon icon-next-disabled" data-icon="next-disabled"></span></a></div></div></div><div class="column is-2-widescreen is-hidden"></div></div><div class="columns foot"><div class="column is-3 is-offset-9 build-by">Build by <a href="https://github.com/ruanyf/loppo" target="_blank">Loppo</a> 0.6.20</div></div><div class="book-toc notification is-warning is-hidden"><h3>Table of chapters &nbsp;<span class="title-close"><a class="button is-danger"> Close</a></span></h3><ul class="chapter-area"><li class="chapter-item"><a href="../操作系统形式化验证/index.html">操作系统形式化验证</a>&nbsp;<a class="first-level-collapse"><span class="icon icon-expand" data-icon="expand"></span></a></li><ul class="chapter-level-1"><li class="chapter-item"><a href="../操作系统形式化验证/fv1.html">操作系统形式化验证实践教程(1) - 证明第一个定理</a></li><li class="chapter-item"><a href="../操作系统形式化验证/fv10.html">操作系统形式化验证实践教程(10) - 一阶直觉逻辑</a></li><li class="chapter-item"><a href="../操作系统形式化验证/fv11.html">操作系统形式化验证实践教程(11) - 结构化证明语言Isar</a></li><li class="chapter-item"><a href="../操作系统形式化验证/fv12.html">操作系统形式化验证实践教程(12) - 经典命题逻辑与公式查错方法</a></li><li class="chapter-item"><a href="../操作系统形式化验证/fv13.html">操作系统形式化验证实践教程(13) - 符号的输入方法</a></li><li class="chapter-item"><a href="../操作系统形式化验证/fv2.html">操作系统形式化验证实践教程(2) - HOL列表与集合</a></li><li class="chapter-item"><a href="../操作系统形式化验证/fv3.html">操作系统形式化验证实践教程(3) - 自动证明工具</a></li><li class="chapter-item"><a href="../操作系统形式化验证/fv4.html">操作系统形式化验证实践教程(4) - 工具环境</a></li><li class="chapter-item"><a href="../操作系统形式化验证/fv5.html">操作系统形式化验证实践教程(5) - 搭建seL4环境</a></li><li class="chapter-item"><a href="../操作系统形式化验证/fv6.html">操作系统形式化验证实践教程(6) - 解析C源代码</a></li><li class="chapter-item"><a href="../操作系统形式化验证/fv7.html">操作系统形式化验证实践教程(7) - C代码的自动验证</a></li><li class="chapter-item"><a href="../操作系统形式化验证/fv8.html">操作系统形式化验证实践教程(8) - 用Haskell做系统建模</a></li><li class="chapter-item"><a href="../操作系统形式化验证/fv9.html">操作系统形式化验证实践教程(9) - 规范与证明概述</a></li></ul><li class="chapter-item"><a href="../符号执行/index.html">符号执行</a>&nbsp;<a class="first-level-collapse"><span class="icon icon-collapse" data-icon="collapse"></span></a></li><ul class="chapter-level-1 chapter-level-1-current"><li class="chapter-item chapter-item-current"><a href="../符号执行/ se1.html">符号执行(1) - 自动生成覆盖率用例之利器</a></li></ul></ul></div><div class="progress-indicator"></div><!-- SCRIPTS --><script>var LOPPO={current_path:"符号执行/ se1.md",relative_root_path:"../",article_toc:'<ul class="markdownIt-TOC">\n<li><a href="#%E4%BB%80%E4%B9%88%E6%98%AF%E7%AC%A6%E5%8F%B7%E6%89%A7%E8%A1%8C">什么是符号执行</a></li>\n<li><a href="#%E9%80%9A%E8%BF%87%E4%BE%8B%E5%AD%90%E5%AD%A6%E4%B9%A0klee%E7%AC%A6%E5%8F%B7%E6%89%A7%E8%A1%8C">通过例子学习klee符号执行</a></li>\n<li><a href="#%E4%B8%A4%E4%B8%AA%E5%8F%82%E6%95%B0%E7%9A%84%E4%BE%8B%E5%AD%90">两个参数的例子</a></li>\n<li><a href="#%E5%B8%A6%E5%BE%AA%E7%8E%AF%E7%9A%84%E4%BE%8B%E5%AD%90">带循环的例子</a></li>\n<li><a href="#%E6%95%B0%E7%BB%84%E5%92%8C%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%9A%84%E4%BE%8B%E5%AD%90">数组和字符串的例子</a></li>\n<li><a href="#%E7%BC%96%E8%AF%91%E5%AE%89%E8%A3%85klee">编译安装klee</a>\n<ul>\n<li><a href="#%E4%B8%8B%E8%BD%BD%E7%BC%96%E8%AF%91minisat">下载编译minisat</a></li>\n<li><a href="#%E4%B8%8B%E8%BD%BD%E7%BC%96%E8%AF%91stp">下载编译stp</a></li>\n<li><a href="#%E4%B8%8B%E8%BD%BD%E7%BC%96%E8%AF%91klee">下载编译klee</a></li>\n</ul>\n</li>\n</ul>\n'}</script><script src="../assets/js/app.js"></script></body></html>